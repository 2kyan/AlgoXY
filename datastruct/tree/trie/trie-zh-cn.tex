\ifx\wholebook\relax \else
% ------------------------

\documentclass[b5paper]{ctexart}
\usepackage[nomarginpar
  %, margin=.5in
]{geometry}

\addtolength{\oddsidemargin}{-0.05in}
\addtolength{\evensidemargin}{-0.05in}
\addtolength{\textwidth}{0.1in}

\usepackage[cn]{../../../prelude}

\setcounter{page}{1}

\begin{document}

\title{基数树}

\author{刘新宇
\thanks{{\bfseries 刘新宇 } \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\maketitle
\fi

\markboth{基数树}{基本算法}

\ifx\wholebook\relax
\chapter{基数树}
\numberwithin{Exercise}{chapter}
\fi

%\section{简介}
\label{introduction} \index{基数树}

排序二叉树将信息存储在节点中。我们可以用边（edge）来携带信息么？基数树（Radix tree），包括trie、前缀树、后缀树就是根据这一思路设计出的数据结构。它们产生于1960年代，被广泛用于编译器\cite{okasaki-int-map}和生物信息处理（如DNA模式匹配）\cite{wiki-suffix-tree}等领域。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{img/radix-tree.ps}
  \caption{基数树}
  \label{fig:radix-tree}
\end{figure}

图\ref{fig:radix-tree}展示了一棵基数树。它包含了二进制串1011、10、011、100、0。如果查找二进制数$k=(b_0b_1...b_n)_2$，我们首先检查左侧的最高位$b_0$。若为0，则转向左子树继续查找；若为1，则转向右子树。接着，我们检查第二位，并重复这一过程直到处理完所有的$n$位或到达某一叶子节点。我们并不需要在节点中存储键（key），这一信息由边来代表。图\ref{fig:radix-tree}标注在节点中的键仅仅是为了示意。对于整数类型的键，我们可以使用二进制，并利用位运算进行操作。

\section{整数trie}
\label{int-trie} \index{基数树!整数trie}

我们称图\ref{fig:radix-tree}所示的数据结构为\emph{binary trie}。Trie是Edward Fredkin在1960年提出的。它来自英文单词re\textbf{trie}val。Fredkin将其读作/'tri:/，但其他人读作/'trai/(和英文单词try的发音相同)\cite{wiki-trie}。有些情况下trie也被称为前缀树，在本章中，trie和前缀树分指不同的数据结构。一棵binary trie是一种特殊的二叉树，每个键的位置由它的二进制位来决定。0表示“向左”，1表示“向右”\cite{okasaki-int-map}。考虑图\ref{fig:big-endian-trie}中的trie，3个不同串``11''、``011''、``0011''代表同一个十进制整数3。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{img/big-endian-trie.ps}
  \caption{大端（big-endian）trie}
  \label{fig:big-endian-trie}
\end{figure}

如果把前面的0也当作有效位，在一个32位整数的系统中，向空trie插入1，结果将是一棵32层的树。为了解决这一问题，Okasaki建议使用小端整数\cite{okasaki-int-map}。二进制数的最高位（MSB）通常在左边，最低位（LSB）在右边。这种形式称为大端整数，反之最高位在右边称为小端整数。使用小端，1表示为$(1)_2$,、2表示为$(01)_2$、3表示为$(11)_2$……

\subsection{定义}
我们可以重用二叉树的定义。一个节点要么为空，要么包含左右子树和一个值（值可以为空）左子树编码为0，右子树编码为1。

\lstset{frame = single}
\begin{Haskell}
data IntTrie a = Empty
               | Branch (IntTrie a) (Maybe a) (IntTrie a)
\end{Haskell}

对于binary trie中的任一节点，其对应的整数键是由节点的位置唯一确定的。因此我们无需在节点中存储键，而只需存储值。键的类型被固定为整数，如果值的类型为$A$，则树的类型为$IntTrie\ A$。

\subsection{插入}
\index{整数trie!插入}

当插入整数键$k$和值$v$时，我们将$k$转换成二进制。如果$k$是偶数，最低位是0，我们递归向左子树插入；如果$k$是奇数，最低位是1，我们递归向右子树插入。接下来我们将$k$除以2取整以去掉最低位。对于非空的trie树$T = (l, v', r)$，其中$l$、$r$是左右子树，$v'$是值（可为空），函数$insert$的定义如下：

\be
\begin{array}{rcl}
insert\ \nil\ k\ v & = & insert (\nil, \textit{Nothing}, \nil)\ k\ v \\
insert\ (l, v', r)\ 0\ v & = & (l, \textit{Just}\ v, r) \\
insert\ (l, v', r)\ k\ v & = & \begin{cases}
  even(k): & (insert\ l\ \dfrac{k}{2}\ v, v', r) \\
  odd(k) : & (l, v', insert\ r\ \lfloor \dfrac{k}{2} \rfloor\ v) \\
\end{cases}
\end{array}
\ee

如果$k = 0$，我们将$v$存入节点。如果$T = \nil$，结果为$(\nil, \textit{Just}\ v, \nil)$。只要$k \neq 0$，我们就根据$k$的奇偶性前进，遇到$\nil$就建立一个空叶子节点$(\nil, \textit{Nothing}, \nil)$。如果$k$已经存在，这一算法覆盖以前的值。我们也可以用一个列表存储多个值，并将$v$添加到列表中。图\ref{int-trie}的例子是依次插入映射对\{$ 1 \rightarrow a, 4 \rightarrow b, 5 \rightarrow c, 9 \rightarrow d$\}的结果。下面的例子程序实现了$insert$函数：

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{img/int-trie.ps}
  \caption{用小端整数trie，包含映射：
          \{$ 1 \rightarrow a, 4 \rightarrow b, 5 \rightarrow c, 9 \rightarrow d$\}}
  \label{fig:int-trie}
\end{figure}

\begin{Haskell}
insert Empty k x = insert (Branch Empty Nothing Empty) k x
insert (Branch l v r) 0 x = Branch l (Just x) r
insert (Branch l v r) k x | even k    = Branch (insert l (k `div` 2) x) v r
                          | otherwise = Branch l v (insert r (k `div` 2) x)
\end{Haskell}

为了判定一个数的奇偶性，我们可以判断它除以2的余数（模2）是否为0：$even(k) = (k \bmod 2 = 0)$，活着使用位运算，如：\texttt{(k \& 0x1) == 0}。我们也可以消除递归用循环实现插入算法：

%\begin{algorithm}
\begin{algorithmic}[1]
\Function{Insert}{$T, k, v$}
  \If{$T =$ NIL}
    \State $T \gets$ \Call{Empty-Node}{}  \Comment{(NIL, Nothing, NIL)}
  \EndIf
  \State $p \gets T$
  \While{$k \neq 0$}
    \If{\Call{Even?}{$k$}}
      \If{\Call{Left}{$p$} = NIL}
        \State \Call{Left}{$p$} $\gets$ \Call{Empty-Node}{}
      \EndIf
      \State $p \gets$ \Call{Left}{$p$}
    \Else
      \If{\Call{Right}{$p$} = NIL}
        \State \Call{Right}{$p$} $\gets$ \Call{Empty-Node}{}
      \EndIf
      \State $p \gets$ \Call{Right}{$p$}
    \EndIf
    \State $k \gets \lfloor k/2 \rfloor$
  \EndWhile
  \State \Call{Value}{$p$} $\gets v$
  \State \Return $T$
\EndFunction
\end{algorithmic}
%\end{algorithm}

\textproc{Insert}接受3个参数：trie树$T$、要插入的键$k$和相应的数据$v$。对于有$m$二进制位的整数$k$，这一算法访问trie中的$m$层，时间复杂度为$O(m)$。

\subsection{查找}
\index{整数trie!查找}

在一棵非空的小端整数trie中查找$k$时，若$k = 0$，则返回根节点中存储的数据。否则根据最后一位是0还是1，在左右子树进行递归查找。

\be
\begin{array}{rcl}
lookup\ \nil\ k & = & \textit{Nothing} \\
lookup\ (l, v, r)\ 0 & = & v \\
lookup\ (l, v, r)\ k & = & \begin{cases}
  even(k): & lookup\ l\ \dfrac{k}{2} \\
  odd(k):  & lookup\ r\ \lfloor \dfrac{k}{2} \rfloor \\
\end{cases}
\end{array}
\ee

下面的例子程序实现了$lookup$函数：

\begin{Haskell}
lookup Empty _ = Nothing
lookup (Branch _ v _) 0 = v
lookup (Branch l _ r) k | even k    = lookup l (k `div` 2)
                        | otherwise = lookup r (k `div` 2)
\end{Haskell}

我们也可以消除递归实现迭代式的查找算法：

\begin{algorithmic}[1]
\Function{Lookup}{$T, k$}
  \While{$k \neq 0$ and $T \neq $NIL}
    \If{ \Call{Even?}{$k$} }
      \State $T \gets$ \Call{Left}{$T$}
    \Else
      \State $T \gets$ \Call{Right}{$T$}
    \EndIf
    \State $k \gets \lfloor k/2 \rfloor$
  \EndWhile
  \If{$T \neq $ NIL}
    \State \Return \Call{Value}{$T$}
  \Else
    \State \Return NIL \EndIf
\EndFunction
\end{algorithmic}

对于有$m$位的整数$k$，$lookup$函数的复杂度为$O(m)$。

\begin{Exercise}
\Question{是否可以将定义\texttt{Branch (IntTrie a) (Maybe a) (IntTrie a)}变为\texttt{Branch (IntTrie a) a (IntTrie a)}，如果值不存在返回\textit{Nothing}，否则返回\textit{Just\ v}？}
\end{Exercise}

\section{整数前缀树}
\label{int-patricia} \index{整数Patricia} \index{整数前缀树}

Trie的缺点是空间消耗大。在图\ref{int-trie}的例子中，只有4个节点存有数据，其它5个节点都是空的。空间利用率不足50\%。为了提高空间利用率，我们可以将链接在一起的节点压缩成一个。前缀树就是这样的数据结构，由Donald R. Morrison在1968年提出。在他的论文中，前缀树被称为Patricia。是\textbf{P}ractical \textbf{A}lgorithm \textbf{T}o \textbf{R}etrieve \textbf{I}nformation \textbf{C}oded \textbf{I}n \textbf{A}lphanumeric的首字母缩写\cite{patricia-morrison}。当键是整数时，我们称之为整数前缀树，或者在不引起歧义的情况下简称为整数树。Okasaki给出了整数前缀树的实现\cite{okasaki-int-map}。将图\ref{fig:int-trie}中链接在一起的节点合并后，可以得到一棵如图\ref{fig:little-endian-patricia}所示的树。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{img/little-endian-patricia.ps}
  \caption{小端整数树实现的映射
     \{$ 1 \rightarrow a, 4 \rightarrow b, 5 \rightarrow c, 9 \rightarrow d$\}}
  \label{fig:little-endian-patricia}
\end{figure}

在整数树中，分枝节点对应的键是它所有子树的公共前缀。这些子树的键在其公共前缀的下一位开始不同。这样整数前缀树消除了不必要的存储空间。

\subsection{定义}

整数前缀树是一种特殊的二叉树。它或者为空，或者是一个如下的节点：

\begin{itemize}
\item 叶子节点：包含一个整数键$k$和一个值$v$；
\item 分枝节点：其左右子树共有一个二进制\textbf{最长公共前缀}，左子树的下一位是0，而右子树的下一位是1。
\end{itemize}

下面的例子代码定义了整数前缀树。分枝节点包含4个部分：最长公共前缀、一个掩码表明从哪一位开始分枝出子树、左右子树。掩码为$m = 2^n$的形式，其中整数$n \geq 0$。所有低于$n$位的二进制位都不属于公共前缀。

\begin{Haskell}
data IntTree a = Empty
               | Leaf Int a
               | Branch Int Int (IntTree a) (IntTree a)
\end{Haskell}

\subsection{插入}
\index{整数前缀树!插入}
当向树$T$插入整数$y$时，若$T$为空，我们用$y$创建一个叶子节点；如果$T$本身只包含一个叶子节点$x$，我们创建一个分枝，并将两个叶子节点$x$和$y$分别设为左右子树。为了确定左右，我们需要找到$x$和$y$的最长公共前缀$p$。例如，$x = 12 = (1100)_2$、$y = 15 = (1111)_2$，则$p = (11oo)_2$，其中$o$表示我们不关心的二进制位，我们使用一个掩码整数$m$来去掉（mask）这些位。在本例中，$m = 4 = (100)_2$，最长公共前缀$p$后面的一位代表$2^1$。$x$中这一位是0，而$y$中这一位是1。因此$x$是左子树，而$y$是右子树。如图\ref{fig:int-patricia-insert-b}所示。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.7]{img/int-patricia-insert-b.ps}
  \caption{Left: $T$ is a leaf of 12; Right: After insert 15.}
  \label{fig:int-patricia-insert-b}
\end{figure}

如果树$T$既不为空，也不是叶子节点，我们需要先比较$y$是否和$T$的最长公共前缀$p$匹配。如果匹配，则根据下一位是0或1递归地在左、右子树中插入。例如，若将$y = 14 = (1110)_2$插入图\ref{fig:int-patricia-insert-b}所示的树，由于最长公共前缀$p = (11oo)_2$，并且接下来的一位（$2^1$位）是1，我们递归地将$y$插入右子树。如果$y$和最长公共前缀$p$不匹配，我们需要分出一个新叶子节点。如图\ref{fig:int-patricia-insert-c}所示。

\begin{figure}[htbp]
  \centering
  \subcaptionbox{插入$14 = (1110)_2$，它和最长公共前缀$p = (1100)_2$匹配，递归插入右子树。}{\includegraphics[scale=0.5]{img/int-patricia-insert-c.ps}}\\
  \subcaptionbox{插入$5 = (101)_2$，它和最长公共前缀$p = (1100)_2$不匹配，分出一个新叶子节点。}{\includegraphics[scale=0.5]{img/int-patricia-insert-d.ps}}
  \caption{根节点为分枝。}
  \label{fig:int-patricia-insert-c}
\end{figure}

如果整数键$k$值为$v$，令叶子节点为$(k, v)$。如果是分枝节点，则记为$(p, m, l, r)$，其中$p$是最长公共前缀，$m$是掩码，$l$和$r$分别是左右子树。下面的$insert$函数包含了上述三种情况：

\be
\resizebox{\textwidth}{!}{\ensuremath{
\begin{array}{rcl}
insert\ \nil\ k\ v\ & = & (k, v) \\
insert\ (k, v')\ k\ v\ & = & (k, v) \\
insert\ (k', v')\ k\ v\ & = & join\ k\ (k, v)\ k'\ (k', v') \\
insert\ (p, m, l, r)\ k\ v\ & = & \begin{cases}
  match(k, p, m): & \begin{cases}
    zero(k, m): & (p, m, insert\ l\ k\ v) \\
    otherwise:  & (p, m, insert\ r\ k\ v) \\
  \end{cases} \\
  otherwise: & join\ k\ (k, v)\ p\ (p, m, l, r) \\
\end{cases} \\
\end{array}
}}
\ee

当$T = \nil$为空时，我们创建一个叶子节点；如果键相同，我们用新值覆盖此前的值。函数$match(k, p, m)$检查整数$k$和最长公共前缀$p$在掩码$m$下是否相同：$mask(k, m) = p$，其中$mask(k, m) = \overline{m-1} \& k$。它先对$m - 1$按位取反，然后和$k$按位与。函数$zero(k, m)$检查掩码$m$之后的二进制位是0还是1。我们将$m$向右移动1位，然后和$k$按位与：

\be
zero(k, m) = k \& (m >> 1)
\ee

函数$join(p_1, T_1, p_2, T_2)$接受两个前缀和两棵树。它从$p_1$、$p_2$抽出最长公共前缀$(p, m) = LCP(p_1, p_2)$，创建一个新分枝，并将$T_1$、$T_2$设为子树：

\be
join(p_1, T_1, p_2, T_2) = \begin{cases}
  zero(p1, m): & (p, m, T_1, T_2) \\
  otherwise: & (p, m, T_2, T_1) \\
\end{cases}
\ee

为了计算最长公共前缀，我们先对$p_1$、$p_2$按位计算异或，然后数出最高位$highest(xor(p_1, p_2))$：

\[
\begin{array}{rcl}
highest(0) & = & 0 \\
highest(n) & = & 1 + highest(n >> 1) \\
\end{array}
\]

接下来我们产生掩码$m = 2^{highest(xor(p_1,p_2))}$。最长公共前缀$p$可以用掩码$m$和$p_1$、$p_2$中的任何一个得出。例如$p = mask(p_1, m)$。下面的例子程序实现了$insert$函数：

\begin{Haskell}
insert t k x
   = case t of
       Empty -> Leaf k x
       Leaf k' x' -> if k == k' then Leaf k x
                     else join k (Leaf k x) k' t
       Branch p m l r
          | match k p m -> if zero k m
                           then Branch p m (insert l k x) r
                           else Branch p m l (insert r k x)
          | otherwise -> join k (Leaf k x) p t

join p1 t1 p2 t2 = if zero p1 m then Branch p m t1 t2
                                else Branch p m t2 t1
    where
      (p, m) = lcp p1 p2

lcp p1 p2 = (p, m) where
    m = bit (highestBit (p1 `xor` p2))
    p = mask p1 m

highestBit x = if x == 0 then 0 else 1 + highestBit (shiftR x 1)

mask x m = x .&. complement (m - 1)

zero x m = x .&. (shiftR m 1) == 0

match k p m = (mask k m) == p
\end{Haskell}

我们也可以用命令式方式实现实现$insert$：

\begin{algorithmic}[1]
\Function{Insert}{$T, k, v$}
  \If{$T = $ NIL}
    \State \Return \Call{Create-Leaf}{$k, v$}
  \EndIf
  \State $y \gets T$
  \State $p \gets$ NIL
  \While{$y$ is not leaf, and \textproc{Match}($k$, \Call{Prefix}{$y$}, \Call{Mask}{$y$})}
    \State $p \gets y$
    \If{\textproc{Zero?}($k$, \Call{Mask}{$y$})}
      \State $y \gets$ \Call{Left}{$y$}
    \Else
      \State $y \gets$ \Call{Right}{$y$}
    \EndIf
  \EndWhile
  \If{$y$ is leaf, and $k = $ \Call{Key}{$y$}}
    \State \Call{Value}{$y$} $\gets v$
  \Else
    \State $z \gets$ \textproc{Branch}($y$, \Call{Create-Leaf}{$k, v$})
    \If{$p = $ NIL}
      \State $T \gets z$
    \Else
      \If{\Call{Left}{$p$} $ = y$}
        \State \Call{Left}{$p$} $\gets z$
      \Else
        \State \Call{Right}{$p$} $\gets z$
      \EndIf
    \EndIf
  \EndIf
  \State \Return $T$
\EndFunction
\end{algorithmic}

其中\textproc{Branch}($T_1, T_2$)创建一个新分枝，抽出最长公共前缀，并将$T_1$和$T_2$设为子树。

\begin{algorithmic}[1]
\Function{Branch}{$T_1, T_2$}
  \State $T \gets$ \Call{Empty-Node}{}
  \State (\Call{Prefix}{$T$}, \Call{Mask}{$T$}) $\gets$ \textproc{LCP}(\Call{Prefix}{$T_1$}, \Call{Prefix}{$T_2$})
  \If{\textproc{Zero?}(\Call{Prefix}{$T_1$}, \Call{Mask}{$T$})}
    \State \Call{Left}{$T$} $\gets T_1$
    \State \Call{Right}{$T$} $\gets T_2$
  \Else
    \State \Call{Left}{$T$} $\gets T_2$
    \State \Call{Right}{$T$} $\gets T_1$
  \EndIf
  \State \Return $T$
\EndFunction
\Statex
\Function{Zero?}{$x, m$}
  \State \Return $(x \& \lfloor \dfrac{m}{2} \rfloor) = 0$
\EndFunction
\end{algorithmic}

函数\textproc{LCP}获取两个整数的最长公共前缀：

\begin{algorithmic}[1]
\Function{LCP}{$a, b$}
  \State $d \gets xor(a, b)$
  \State $m \gets 1$
    \While{$d \neq 0$}
    \State $d \gets \lfloor \dfrac{d}{2} \rfloor$
    \State $m \gets 2m$
  \EndWhile
  \State \Return (\Call{MaskBit}{$a, m$}, $m$)
\EndFunction
\Statex
\Function{MaskBit}{$x, m$}
  \State \Return $x \& \overline{m - 1}$
\EndFunction
\Statex
\end{algorithmic}

图\ref{fig:int-patricia-haskell-insert}展示了使用插入算法构造的前缀树。虽然整数前缀树压缩了链接在一起的节点，但获取最长前缀仍然需要线性扫描二进制位，对$m$位整数，插入算法的复杂度是$O(m)$。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.6]{img/int-patricia-haskell-insert.ps}
  \caption{插入映射$1 \rightarrow x, 4 \rightarrow y, 5 \rightarrow z$到大端整数前缀树}
  \label{fig:int-patricia-haskell-insert}
\end{figure}


\subsection{查找}
\index{整数前缀树!查找}

当查找整数$k$时，如果树$T = \nil$为空，或者是键为其它整数的叶子节点$T = (k', v)$，则$k$不存在；如果$k = k'$，则$v$为查找结果。如果$T = (p, m, l, r)$是一个分枝节点，我们需要检查公共前缀$p$和$k$在掩码$m$下是否匹配，并根据下一位递归在子树$l$或$r$中查找。如果不匹配公共前缀$p$，则$k$不存在。

\be
\begin{array}{rcl}
lookup\ \nil\ k & = & \textit{Nothing} \\
lookup\ (k', v)\ k & = & \begin{cases}
  k = k': & \textit{Just}\ v \\
  otherwise: & \textit{Nothing} \\
  \end{cases} \\
lookup\ (p, m, l, r)\ k & = & \begin{cases}
  match(k, p, m): & \begin{cases}
    zero(k, m): & lookup\ l\ k \\
    otherwise: &  lookup\ r\ k \\
    \end{cases} \\
  otherwise: & \textit{Nothing} \\
  \end{cases}\\
\end{array}
\ee

%% \begin{Haskell}
%% lookup Empty _ = Nothing
%% lookup (Leaf k' v) k = if k == k' then Just v else Nothing
%% lookup (Branch p m l r) k | match k p m = if zero k m then lookup l k else lookup r k
%%                           | otherwise = Nothing
%% \end{Haskell}

我们也可以消除递归用迭代的命令式方法实现查找。

\begin{algorithmic}[1]
\Function{Look-Up}{$T, k$}
  \If{$T =$ NIL}
    \State \Return NIL
  \EndIf
  \While{$T$ is not leaf, and \textproc{Match}($k$, \Call{Prefix}{$T$}, \Call{Mask}{$T$})}
    \If{\textproc{Zero?}($k$, \Call{Mask}{$T$})}
      \State $T \gets$ \Call{Left}{$T$}
    \Else
      \State $T \gets$ \Call{Right}{$T$}
    \EndIf
  \EndWhile
  \If{$T$ is leaf, and \Call{Key}{$T$} $=k$}
    \State \Return \Call{Value}{$T$}
  \Else
    \State \Return NIL
  \EndIf
\EndFunction
\end{algorithmic}

对于有$m$二进制位的整数，$lookup$算法的复杂为$O(m)$。

\begin{Exercise}
\Question{编写程序实现整数前缀树的$lookup$算法。}
\Question{实现整数trie和整数树的前序遍历，仅输出值不为空的节点键。结果有何规律？}
\end{Exercise}

\section{Trie}
\index{trie}

在整数trie和整数前缀树的基础上，我们可以把键的类型从整数扩展到列表。其中一个特例是作为字符列表的字符串。前缀树和trie可以作为文本处理的有力工具。

\subsection{定义}
当键从二进制0/1扩展到通用列表时，树结构也自然从二叉树扩展为多分枝树。拿英语来说，一共有26个字符，如果忽略大小写，分枝的个数可以达到26，如图\ref{fig:trie-of-26}所示。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.45]{img/trie-of-26.ps}
  \caption{含有多达26个分枝的trie，包含键：a、an、another、bool、boy、zoo}
  \label{fig:trie-of-26}
\end{figure}

并非所有的26棵子树都包含数据。在图\ref{fig:trie-of-26}的根节点的分枝中，只有代表a、b、z的3棵子树不为空。其它分枝，例如代表c的子树，全部是空的。我们可以将这些空子树隐藏起来。如果区分大小写或者进一步将类型从字符串扩展到列表，我们可以通过使用map等数据结构来处理动态数目的分枝。

一棵trie或者为空，或者是一个节点，包含以下两种情况：

\begin{enumerate}
\item 值为$v$的叶子节点，不含有子树；
\item 分支节点，包含值$v$和多棵子树。每棵子树对应类型$K$中的某个值$k$。
\end{enumerate}

若树中值的类型为$V$，我们记trie的类型为$Trie\ K\ V$。下面的例子程序定义了trie：

\begin{Haskell}
data Trie k v = Trie { value :: Maybe v
                     , subTrees :: [(k, Trie k v)]}
\end{Haskell}

内容为空的树被定义为：$(\textit{Nothing}, \nil)$

\subsection{插入}
\index{trie!插入}

考虑插入一对键、值到trie中，其中键为若干元素的列表。令trie为$T = (v, ts)$，其中$v$是树中存储的值，$ts = \{ c_1 \mapsto T_1, c_2 \mapsto T_2, ..., c_m \mapsto T_m \}$包含字符和子树间的映射。元素$c_i$映射到子树$T_iT$。我们可以使用关联列表$[(c_1, T_1), (c_2, T_2), ..., (c_m, T_m)]$或者自平衡树实现映射（见第4、5章）。

\be
\begin{array}{rcl}
insert\ (v, ts)\ \nil\ v' & = & (v', ts) \\
insert\ (v, ts)\ (k:ks)\ v' & = & (v, ins\ ts) \\
\end{array}
\ee

如果键为空，我们覆盖掉以前的值；否则，我们取出第一个元素$k$，找到映射到$k$的子树，并递归将$ks$和$v'$插入：

\be
\begin{array}{rcl}
ins\ \nil & = & [k \mapsto insert\ (\textit{Nothing}, \nil)\ ks\ v'] \\
ins\ ((c \mapsto t) : ts) & = & \begin{cases}
  c = k: & (k \mapsto insert\ t\ ks\ v') : ts \\
  otherwise: & (c \mapsto t) : (ins\ ts) \\
  \end{cases}
\end{array}
\ee

如果没有子树映射到$k$，我们就新建一棵空子树$t = (\textit{Nothing}, \nil)$，并将$k$映射到其上；否则，我们找到映射到$k$的子树$t$，递归地向$t$中插入$ks$和$v'$。下面的例子程序实现了$insert$函数，它使用关联列表保存映射。

\begin{Haskell}
insert (Trie _ ts) [] x = Trie (Just x) ts
insert (Trie v ts) (k:ks) x = Trie v (ins ts) where
    ins [] = [(k, insert empty ks x)]
    ins ((c, t) : ts) = if c == k then (k, insert t ks x) : ts
                        else (c, t) : (ins ts)

empty = Trie Nothing []
\end{Haskell}

我们也可以消除递归，实现迭代方式的$insert$函数：

\begin{algorithmic}[1]
\Function{Insert}{$T, k, v$}
  \If{$T = $ NIL}
    \State $T \gets $ \Call{Empty-Node}{}
  \EndIf
  \State $p \gets T$
  \For{each $c$ in $k$}
    \If{\Call{Sub-Trees}{$p$}[c] = NIL}
      \State \Call{Sub-Trees}{$p$}[c] $\gets$ \Call{Empty-Node}{}
    \EndIf
    \State $p \gets $ \Call{Sub-Trees}{$p$}[c]
  \EndFor
  \State \Call{Value}{$p$} $\gets v$
  \State \Return $T$
\EndFunction
\end{algorithmic}

若键的类型为$[K]$（$K$的列表），若$K$是包含$m$个元素的有限集，键的长度为$n$，则插入算法的复杂度为$O(mn)$。当键是小写英文字符串时，$m = 26$，插入操作的复杂度和字符串长度成正比。

\subsection{查找}
\index{trie!查找}

在$T = (v, ts)$中查找一个非空键$(k:ks)$时，我们从第一个元素$k$开始，如果存在映射到$k$的子树$T'$，则接下来递归地在$T'$中查找$ks$。当键为空时，返回当前节点的值作为结果：

\be
\begin{array}{rcl}
lookup\ \nil\ (v, ts) & = & v \\
lookup\ (k:ks)\ (v, ts) & = & \begin{cases}
  lookup_{l}\ k\ ts = \textit{Nothing}: & \textit{Nothing} \\
  lookup_{l}\ k\ ts = \textit{Just}\ t: & lookup\ ks\ t \\
\end{cases}
\end{array}
\ee

其中函数$lookup_{l}$的定义见第一章。它在关联列表中查找键是否存在。下面是相应的迭代实现：

\begin{algorithmic}[1]
\Function{Look-Up}{$T, key$}
  \If{$T = $ NIL}
    \State \Return \textit{Nothing}
  \EndIf
  \For{each $c$ in $key$}
    \If{\Call{Sub-Trees}{$T$}[$c$] = NIL}
      \State \Return \textit{Nothing}
    \EndIf
    \State $T \gets $ \Call{Sub-Trees}{$T$}[$c$]
  \EndFor
  \State \Return \Call{Value}{$T$}
\EndFunction
\end{algorithmic}

查找算法的复杂度为$O(mn)$，其中$n$是键的长度，$m$是元素所在集合的大小。

\begin{Exercise}
\Question{使用自平衡二叉树（如红黑树或AVL树）实现映射$map$数据结构，用以存储子树的映射。我们称其为$MapTrie$或$MapTree$。它们的插入和查找算法性能是怎样的？}
\end{Exercise}

\section{前缀树}
\index{Patricia} \index{前缀树}

Trie的空间利用率很低。我们可以用同样的方法压缩链接在一起的节点，这样就得到了前缀树。

\subsection{定义}
一个前缀树节点$t$包含两部分：一个可为空的值$v$、零个或若干子前缀树。每棵子树$t_i$对应到一个列表$s_i$。列表和子树的映射关系记为$[s_i \mapsto t_i]$。这些列表拥有共同的前缀$s$，而$s$映射到节点$t$。也就是说$s$是$s \doubleplus s_1$、$s \doubleplus s_2$……的最长公共前缀。对于任何$i \neq j$，列表$s_i$、$s_j$不存在非空的公共前缀。将图\ref{fig:trie-of-26}中链接在一起的节点压缩起来，可以得到如图\ref{fig:patricia-tree}的前缀树。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{img/patricia-tree.ps}
  \caption{一棵前缀树，包含键：a、an、another、bool、boy、zoo}
  \label{fig:patricia-tree}
\end{figure}

下面的例子程序定义了前缀树：

\begin{Haskell}
data PrefixTree k v = PrefixTree { value :: Maybe v
                                 , subTrees :: [([k], PrefixTree k v)]}
\end{Haskell}

我们记前缀树为$t = (v, ts)$。特别地，$(\textit{Nothing}, \nil)$表示内容为空的节点；$(\textit{Just}\ v, \nil)$表示值为$v$的叶子节点。

\subsection{插入}
\index{前缀树!插入}

插入字符串$s$时，若前缀树为空，我们为$s$创建一个叶子节点，如图\ref{fig:patricia-insert}(a)所示。如果$s$和某个子树$t_i$相对应$s_i$存在公共前缀，我们创建一个新叶子节点$t_j$，抽出公共前缀，并将其映射到一个新分枝$t'$上，然后令$t_i$、$t_j$分别为$t'$的两棵子树。如图\ref{fig:patricia-insert}(b)所示。这里有两种特殊情况：$s$为$s_i$的前缀，如图\ref{fig:patricia-insert}(c) $\to$ (e)；以及$s_i$为$s$的前缀，如图\ref{fig:patricia-insert}(d) $\to$ (e)。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{img/prefix-tree-insert.png}
  \caption{(a) 向空树插入boy；(b) 插入bool，创建新分枝；(c) 向(b)插入another (d) 向(b)插入an (e) 向(c)插入an，结果与向(d)插入another相同}
  \label{fig:patricia-insert}
\end{figure}

下面的函数向前缀树$t = (v', ts)$中插入键$s$和值$v$：

\be
\begin{array}{rcl}
insert\ (v', ts)\ \nil\ v & = & (\textit{Just}\ v, ts) \\
insert\ (v', ts)\ s\ v & = & (v', ins\ ts) \\
\end{array}
\ee

如果键$s$为空，我们用$v$覆盖掉以前的值；否则调用$ins$检查子树和它们的前缀。

\be
\begin{array}{rcl}
ins\ \nil\ & = & [ s \mapsto (\textit{Just}\ v, \nil) ] \\
ins\ (s' \mapsto t) : ts' & = & \begin{cases}
  match\ s\ s': & (branch\ s\ v\ s'\ t) : ts' \\
  otherwise: & (s' \mapsto t) : ins\ ts' \\
  \end{cases}
\end{array}
\ee

如果节点不含任何子树，我们创建一个值为$v$的子树，并将$s$映射到其上；否则，对于每个子树映射$s' \mapsto t$，我们比较$s'$和$s$。如果它们有公共前缀（通过$match$函数检测），则利用$branch$函数分枝出子树。我们定义两个列表匹配如果它们有公共前缀：

\be
\begin{array}{rcl}
match\ \nil\ B & = & True \\
match\ A\ \nil & = & True \\
match\ (a:as)\ (b:bs) & = & a = b \\
\end{array}
\ee

我们定义函数$(C, A', B') = lcp\ A\ B$来提取列表$A$和$B$的最长公共前缀，其中$C \doubleplus A' = A$且$C \doubleplus B' = B$成立。如果$A$、$B$中的任何一个为空或者它们的第一个元素不同，则公共前缀$C = \nil$；否则，我们递归地从子列表中提取公共前缀，并将头部元素附加在前：

\be
\begin{array}{rcl}
lcp\ \nil\ B & = & (\nil, \nil, B) \\
lcp\ A\ \nil & = & (\nil, A, \nil) \\
lcp\ (a:as)\ (b:bs) & = & \begin{cases}
  a \neq b: & (\nil, a:as, b:bs) \\
  otherwise: & (a:cs, as', bs')\\
  \end{cases}
\end{array}
\ee

其中$(cs, as', bs') = lcp\ as\ bs$是递归提取的结果，函数$branch\ A\ v\ B\ t$接受两个键$A$、$B$，一个值$v$和树$t$，它提取出$A$、$B$的最长公共前缀$C$，将其映射到新分枝节点上，并设置好子树：

\be
\begin{array}{l}
branch\ A\ v\ B\ t = \\
\ lcp\ A\ B = \begin{cases}
   (C, \nil, B'): & (C, (\textit{Just}\ v, [B' \mapsto t])) \\
   (C, A', \nil): & (C, insert\ t\ A'\ v) \\
   (C, A', B'): & (C, (\textit{Nothing}, [A' \mapsto (\textit{Just}\ v, \nil), B' \mapsto t])) \\
\end{cases}
\end{array}
\ee

如果$A$是$B$的前缀，则将$A$映射到$v$所在的节点，列表的剩余部分被重新映射到分枝的唯一子树$t$；如果$B$是$A$的前缀，我们递归地将剩余列表和值插入到$t$中；否则，我们创建一个值为$v$的叶子节点，将其和$t$作为分枝的两棵子树。下面的例子程序实现了$insert$算法：

\begin{Haskell}
insert (PrefixTree _ ts) [] v = PrefixTree (Just v) ts
insert (PrefixTree v' ts) k v = PrefixTree v' (ins ts) where
    ins [] = [(k, leaf v)]
    ins ((k', t) : ts) | match k k' = (branch k v k' t) : ts
                       | otherwise  = (k', t) : ins ts

leaf v = PrefixTree (Just v) []

match [] _ = True
match _ [] = True
match (a:_) (b:_) = a == b

branch a v b t = case lcp a b of
  (c, [], b') -> (c, PrefixTree (Just v) [(b', t)])
  (c, a', []) -> (c, insert t a' v)
  (c, a', b') -> (c, PrefixTree Nothing [(a', leaf v), (b', t)])

lcp [] bs = ([], [], bs)
lcp as [] = ([], as, [])
lcp (a:as) (b:bs) | a /= b = ([], a:as, b:bs)
                  | otherwise = (a:cs, as', bs') where
                        (cs, as', bs') = lcp as bs
\end{Haskell}

我们也可以消除递归，用循环实现插入算法：

\begin{algorithmic}[1]
\Function{Insert}{$T, k, v$}
  \If{$T = $ NIL}
   \State $T \gets$ \Call{Empty-Node}{}
  \EndIf
  \State $p \gets T$
  \Loop
    \State $match \gets$ FALSE
    \For{each $s_i \mapsto T_i $ in \Call{Sub-Trees}{$p$}}
      \If{$k = s_i$}
        \State \Call{Value}{$T_i$} $\gets v$ \Comment{覆盖}
        \State \Return $T$
      \EndIf
      \State $c \gets$ \Call{LCP}{$k, s_i$}
      \State $k_1 \gets k - c$, $k_2 \gets s_i - c$
      \If{$c \neq $ NIL}
        \State $match \gets$ TRUE
        \If{$k_2 = $ NIL} \Comment{$s_i$是$k$的前缀}
          \State $p \gets T_i$, $k \gets k_1$
          \State break
        \Else \Comment{新分枝}
          \State \textproc{Add}(\Call{Sub-Trees}{$p$}, $c \mapsto$ \textproc{Branch}($k_1$, \Call{Leaf}{$v$}, $k_2$, $T_i$))
          \State \textproc{Delete}(\Call{Sub-Trees}{$p$}, $s_i \mapsto T_i$)
          \State \Return $T$
        \EndIf
      \EndIf
    \EndFor
    \If{not $match$} \Comment{新叶子}
      \State \textproc{Add}(\Call{Sub-Trees}{$p$}, $k \mapsto$ \Call{Leaf}{$v$})
      \State break
    \EndIf
  \EndLoop
  \State \Return $T$
\EndFunction
\end{algorithmic}

函数\textproc{LCP}提取出两个列表的公共前缀：

\begin{algorithmic}[1]
\Function{LCP}{$A, B$}
  \State $i \gets 1 $
  \While{$i \leq |A|$ and $i \leq |B|$ and $A[i] = B[i]$}
    \State $i \gets i + 1$
  \EndWhile
  \State \Return $A[1...i-1]$
\EndFunction
\end{algorithmic}

\textproc{Branch}($s_1, T_1, s_2, T_2$)中需要处理特殊情况。如果$s_1$为空，说明待插入的键是某个子树的前缀，我们将$T_2$设置为$T_1$的子树。否则，我们创建一个新的分枝节点，并将$T_1$、$T_2$设置为子树。

\begin{algorithmic}[1]
\Function{Branch}{$s_1, T_1, s_2, T_2$}
  \If{$s_1 = $ NIL}
    \State \textproc{Add}(\Call{Sub-Trees}{$T_1$}, $s_2 \mapsto T_2$)
    \State \Return $T_1$
  \EndIf
  \State $T \gets$ \Call{Empty-Node}{}
  \State \Call{Sub-Trees}{$T$} $\gets \{s_1 \mapsto T_1, s_2 \mapsto T_2\}$
  \State \Return $T$
\EndFunction
\end{algorithmic}

虽然前缀树提高了空间利用率，但其复杂度仍然是$O(mn)$，其中$n$是键的长度，$m$是列表元素集合的大小。

\subsection{查找}
\index{前缀树!查找}

查找键$k$时，我们从根节点开始，如果$k = \nil$为空，则返回根节点的值；否则我们检查子树的映射，找到映射$s_i \mapsto t_i$，使得$s_i$是$k$的前缀，然后再递归地在子树$t_i$中查找$k - s_i$。如果所有的$s_i$都不是$k$的前缀，则树中不存在要查找的键。

\be
\begin{array}{rcl}
lookup\ \nil\ (v, ts) & = & v \\
lookup\ k\ (v, ts) & = & find\ ((s, t) \mapsto s \sqsubseteq k)\ ts\ =  \\
  & & \begin{cases}
    \textit{Nothing} : & Nothing \\
    \textit{Just}\ (s, t): & lookup\ (k - s)\ t
  \end{cases}
\end{array}
\ee

其中$A \sqsubseteq B$表示$A$是$B$的前缀。函数$find$的定义见第一章，它在列表中查找满足指定条件的元素。下面的例子程序实现了查找算法。

\begin{Haskell}
lookup [] (PrefixTree v _) = v
lookup ks (PrefixTree v ts) =
  case find (\(s, t) -> s `isPrefixOf` ks) ts of
    Nothing -> Nothing
    Just (s, t) -> lookup (drop (length s) ks) t
\end{Haskell}

前缀检查所需的时间和列表的长度成比例，$lookup$算法的复杂度为$O(mn)$，其中$m$是列表元素集合的大小，$n$是列表的长度。我们略过了命令式实现，将其作为本节的练习。

\begin{Exercise}
\Question{消除$lookup$算法中的递归，用循环实现前缀树的查找。}
\end{Exercise}

\section{Trie和前缀树的应用}

我们可以用trie和前缀树来解决许多有趣的问题，包括实现简单的词典，自动输入补齐，以及数字键盘输入法。与商业实现不同，本节给出的例子都是示意性的。

\subsection{词典和自动补齐}
\index{自动补齐}

图\ref{fig:e-dict}展示的是某英汉电子词典的界面。为了易用，当用户输入某些字符后，电子词典会搜索词库，将所有候选单词全部列出。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{img/edict-en.png}
  \caption{电子词典。所有和用户输入匹配的候选单词全被列出}
  \label{fig:e-dict}
\end{figure}

电子词典通常存有数十万单词。进行全词查找的开销很大。商业电子词典软件会同时使用多重方法以提高性能，包括缓存（caching）、索引（indexing）等等。

和电子词典类似，图\ref{fig:word-completion}显示了某互联网搜索引擎的界面。当用户输入内容后，会列出一些可能的候选搜索项。这些项的开头部分和用户输入相匹配\footnote{实际功能会更加复杂，包括拼写检查，关键词提取、引导等。}，并且按照被搜索的热门程度排序。被搜索的次数越多，越排在前面。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{img/adaptive-input.png}
  \caption{搜索引擎。和用户输入匹配的候选搜索被列出}
  \label{fig:word-completion}
\end{figure}

这两个例子中，软件都提供了某种自动完成的机制。在某些现代的IDE（集成开发环境）中，编辑器还可以帮助用户自动完成程序代码。

我们看看如何使用前缀树来实现电子词典。为了简化问题，假设我们的词典是英—英词典。

词典中保存了key-value对，key是英文单词或者词组，value是对应的解释。

当用户输入‘a’的时候，词典不是只给出‘a’的意思，而是提供一系列候选单词的列表。这些候选单词都以‘a’开头，包括abandon、about、accent、adam……当然，这些都是存储在前缀树中的单词。

如果候选单词太多，一种方案是只显示前10个，如果用户查找的单词不在其中，他可以浏览更多的候选项。如果待查找的字符串为空，我们从当前节点扩展出前$n$个子节点作为候选项；否则，我们递归地在有共同前缀的子分支中查找。

在支持惰性求值（lazy evaluation）的编程环境中，一种简单直观的方法是惰性扩展全部的子节点，然后根据需要取前$n$个。记前缀树前缀树为$T = (v, C)$，下面的函数枚举所有以$k$开头的内容。

\be
findAll(T, k) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  enum(C) & k = \phi, v = \phi \\
  \{(\phi, v)\} \cup enum(C) & k = \phi, v \neq \phi \\
  find(C, k) & k \neq \phi
  \end{array}
\right.
\ee

前两行处理key为空的边界情况。此时，我们通过枚举扩展所有数据不为空的子节点。最后一行调用$find$函数寻找和前缀$k$匹配的子分支。

如果节点的子分支不为空，记$C = \{(k_1, T_1), (k_2, T_2), ..., (k_m, T_m)\}$，令除去第一对映射以外的剩余映射为$C'$。枚举算法可以定义如下：

\be
enum(C) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  \phi & C = \phi \\
  mapAppend(k_1, findAll(T_1, \phi)) \cup enum(C')
  \end{array}
\right.
\ee

其中$mapAppend(k, L) = \{(k + k_i, v_i)| (k_i, v_i) \in L\}$。它将前缀$k$添加到列表$L$中的所有key-value对的key前面\footnote{可以进一步抽象为对第一个元素进行映射。在Haskell中，使用范畴论中的箭头概念，$mapAppend$可被表示为$map(first(k+), L)$}。

函数$enum$也可用$concatMap$的概念定义（亦称为$flatMap$）\footnote{效果上相当于先对每个元素进行映射，然后将结果连接起来。通常使用build-foldr来消除中间结果中的列表}。

\be
enum(C) = concatMap(\lambda_{(k, T)} . mapAppend(k, findAll(T, \phi)))
\ee

函数$find(C, k)$定义如下。如果子树为空，结果也为空；否则，它首先检查$k_1$映射的子树$T_1$。如果$k_1$和$k$相等，就调用$mapAppend$向$T_1$所有子分支的key前增加前缀$k$；如果$k_1$是$k$的前缀，算法就递归地查找所有以$k - k_1$开头的子分支；反之，如果$k$是$k_1$的前缀，则$T_1$的所有子分支都是候选项。否则，算法跳过第一对映射，继续处理剩余的其他映射。

\be
find(C, k) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  \phi & C = \phi \\
  mapAppend(k_1, findAll(T_1, \phi)) & k \sqsubset k_1 \\
  mapAppend(k_1, findAll(T_1, k - k_1)) & k_1 \sqsubset k \\
  find(C', k) & otherwise
  \end{array}
\right.
\ee

下面的Haskell例子程序按照上述算法实现了一个简单的电子词典：

\lstset{language=Haskell}
\begin{lstlisting}[style=Haskell]
import Control.Arrow (first)

get n t k = take n $ findAll t k

findAll :: Eq k => PrefixTree k v -> [k] -> [([k], v)]
findAll (PrefixTree Nothing cs) [] = enum cs
findAll (PrefixTree (Just x) cs) [] = ([], x) : enum cs
findAll (PrefixTree _ cs) k = find' cs k
  where
    find' [] _ = []
    find' ((k', t') : ps) k
          | k `isPrefixOf` k'
              = map (first (k' ++)) (findAll t' [])
          | k' `isPrefixOf` k
              = map (first (k' ++)) (findAll t' $ drop (length k') k)
          | otherwise = find' ps k

enum :: Eq k => [([k], PrefixTree k v)] -> [([k], v)]
enum = concatMap (\(k, t) -> map (first (k ++)) (findAll t []))
\end{lstlisting}

在Haskell这样的惰性求值编程环境中，前$n$个候选项可以通过$take(n, findAll(T, k))$来获取。附录A给出了$take$函数的详细定义。

也可以用命令式的方式实现电子词典。下面的算法复用了前面定义的前缀树查找函数。当我们找到一个节点，其对应的前缀和用户输入的内容一致时，算法将扩展该节点的所有子树直到获取到前$n$个候选项。

\begin{algorithmic}[1]
\Function{Look-Up}{$T, k, n$}
  \If{$T = $ NIL}
     \State \Return $\phi$
  \EndIf
  \State $prefix \gets$ NIL
  \Repeat
    \State $match \gets$ FALSE
    \For{$\forall (k_i, T_i) \in $ \Call{Children}{$T$}}
      \If{$k$ is prefix of $k_i$}
        \State \Return \Call{Expand}{$prefix + k _i, T_i, n$}
      \EndIf
      \If{$k_i$ is prefix of $k$}
        \State $match \gets$ TRUE
        \State $k \gets k - k_i$
        \State $T \gets T_i$
        \State $prefix \gets prefix + k_i$
        \State break
      \EndIf
    \EndFor
  \Until{$\lnot match$}
  \State \Return $\phi$
\EndFunction
\end{algorithmic}

其中函数\textproc{Expand}($T, prefix, n$)选取$n$个子树，这些子树在$T$中有同样的前缀。它的实现为广度优先遍历（BFS），本书最后一章对包括广度优先在内的搜索算法有详细的介绍。

\begin{algorithmic}[1]
\Function{Expand}{$prefix, T, n$}
  \State $R \gets \phi$
  \State $Q \gets \{(prefix, T)\}$
  \While{$|R| < n \land Q$ is not empty}
    \State $(k, T) \gets$ \Call{Pop}{$Q$}
    \If{\Call{Data}{$T$} $\neq$ NIL}
      \State $R \gets R \cup \{(k, $ \Call{Data}{$T$} $)\}$
    \EndIf
    \For{$\forall (k_i, T_i) \in$ \Call{Children}{$T$} in sorted order}
      \State \Call{Push}{$Q, (k + k_i, T_i)$}
    \EndFor
  \EndWhile
\EndFunction
\end{algorithmic}

下面的Python例子程序实现了一个电子词典。它使用了标准库中的\texttt{find}函数来判断一个字符串是否是另一个的前缀。

\lstset{language=Python}
\begin{lstlisting}
def lookup(t, key, n):
    if t is None:
        return []
    prefix = ""
    while True:
        match = False
        for k, tr in t.subtrees.items():
            if string.find(k, key) == 0: # key is prefix of k
                return expand(prefix + k, tr, n)
            if string.find(key, k) ==0:
                match = True
                key = key[len(k):]
                t = tr
                prefix += k
                break
        if not match:
            break
    return []

def expand(prefix, t, n):
    res = []
    q = [(prefix, t)]
    while len(res)<n and q:
        (s, p) = q.pop(0)
        if p.value is not None:
            res.append((s, p.value))
        for k, tr in sorted(p.subtrees.items()):
            q.append((s + k, tr))
    return res
\end{lstlisting}

%=====================================
% T9
%=====================================

\subsection{T9输入法}
\index{T9}
\index{Textonym输入法}

手机用户编辑短信或者电子邮件时的体验和PC上完全不同。手机键盘（称为ITU-T键盘）上只有非常少的按键。如图\ref{fig:itut-keypad}所示。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{img/itu-t.png}
  \caption{手机ITU-T键盘}
  \label{fig:itut-keypad}
\end{figure}

在ITU-T键盘上输入英文单词或短语有两种方法。例如用户要输入单词home，他需要按照下面的顺序按键：

\begin{itemize}
\item 按两次4键以输入字符h；
\item 按三次6键以输入字符o；
\item 按一次6键以输入字符m；
\item 按两次3键以输入字符e；
\end{itemize}

另外一种更快速的方法使用下面的按键顺序：

\begin{itemize}
\item 依次按下4、6、6、3，单词home出现在候选列表的最上方；
\item 按下‘*’号键以变换不同的候选单词，good此时出现在候选列表上；
\item 按下‘*’号键再次变换，下一个候选单词gone出现在列表上；
\item ……
\end{itemize}

对比这两个方法，可以发现后者更加方便，但是需要额外保存一个候选单词字典。这种方法被称作“T9输入法”或预测输入法\cite{wiki-t9}、\cite {wiki-predictive-text}。T9是英文textonym的缩写，它以T开头，后面跟9个字母。T9输入法可以用前缀树来实现。

为了向用户提供候选单词，T9输入法需要预先准备一个词典。商业上的T9输入法通常使用更加复杂的索引词典，同时在文件系统和缓存中进行快速索引。本节中的实现仅仅出于演示的目的。

首先我们需要定义T9键盘映射，它将数字映射为候选字符。

\be
\begin{array}{ll}
M_{T9} = \{ & 2 \rightarrow abc, 3 \rightarrow def, 4 \rightarrow ghi, \\
           & 5 \rightarrow jkl, 6 \rightarrow mno, 7 \rightarrow pqrs, \\
           & 8 \rightarrow tuv, 9 \rightarrow wxyz \}
\end{array}
\ee

使用这一映射后，$M_{T9}[i]$就返回数字$i$对应的若干个字符。我们也可以定义从字符到数字的逆映射。

\be
M^{-1}_{T9} = concat(\{\{c \rightarrow d | c \in S\} | (d \rightarrow S) \in M_{T9}\})
\ee

通过查找$M^{-1}_{T9}$，我们可以将字符串转换成一组按键序列。

\be
digits(S) = \{ M^{-1}_{T9}[c]| c \in S \}
\ee


给定一个数字序列$D = d_1d_2...d_n$，我们定义T9查找的算法如下。

\be
findT9(T, D) = \left \{
  \begin{array}
  {r@{\quad:\quad}l}
  \{ \phi \} & D = \phi \\
  concatMap(find, prefixes(T)) & otherwise
  \end{array}
\right.
\ee

其中$T$是从一组单词和词组中构造出的前缀树。我们将其作为T9输入法的词典。若输入的数字串$D$为空，则候选单词的结果列表也是空。否则，我们搜索匹配输入的子树并将结果连接起来。

为了枚举所有匹配的子树，我们检查子树集$C_T$中的每一对$(k_i, T_i)$。首先将字符串$k_i$转换为数字串$d_i$，然后比较$d_i$和$D$。如果其中之一是另一个的前缀，则选中这一对$(k_i, T_i)$进行进一步查找。

\be
prefixes(T) = \{(k_i, T_i) | (k_i, T_i) \in C_T, d_i = digits(k_i), d_i \sqsubset D \lor D \sqsubset d_i \}
\ee

函数$find$接受两个参数，一个前缀$S$和需要进一步查找的子树$T'$。其中$S$是$D$的前缀。为此，我们从$D$中去除这一前缀，然后用剩余的数字串$D' = D - S$继续查找。最后再将$S$添加回递归查找的各个结果前面。

\be
find(S, T') = \{ take(n, S + s_i) | s_i \in findT9(T', D - S) \}
\ee

其中$n = |D|$是输入数字串的长度。函数$take(n, L)$从列表$L$中获取前$n$个元素。如果列表的长度短于$n$，则获取全部元素。

下面的Haskell例子程序实现了从前缀树查找的T9输入法。

\lstset{language=Haskell}
\begin{lstlisting}
import qualified Data.Map as Map

mapT9 = Map.fromList [('1', ",."), ('2', "abc"), ('3', "def"), ('4', "ghi"),
                      ('5', "jkl"), ('6', "mno"), ('7', "pqrs"), ('8', "tuv"),
                      ('9', "wxyz")]

rmapT9 = Map.fromList $ concatMap (\(d, s) -> [(c, d) | c <- s]) $ Map.toList mapT9

digits = map (\c -> Map.findWithDefault '#' c rmapT9)

findT9 :: PrefixTree Char v -> String -> [String]
findT9 t [] = [""]
findT9 t k = concatMap find prefixes
  where
    n = length k
    find (s, t') = map (take n . (s++)) $ findT9 t' (k `diff` s)
    diff x y = drop (length y) x
    prefixes = [(s, t') | (s, t') <- children t, let ds = digits s in
                          ds `isPrefixOf` k || k `isPrefixOf` ds]
\end{lstlisting}  %$

可以使用广度优先搜索实现命令式的T9输入法。我们使用一个队列$Q$，其保存的元素为三元组
$(prefix, D, T)$。每个三元组包含一个已搜索过的前缀$prefix$，尚未搜索的剩余部分$D$，
还有待搜索的子树$T$。队列初始的时候，三元组包含一个空前缀，全部待搜索的数字，以及前缀树
的根节点。算法不断从队列中取出三元组，对其中的树$T$，依次检查它的子树$T_i$。通过检索
T9的逆映射，我们将子树对应的前缀串$k_i$转换成数字串$D'$。如果$D$是$D'$的前缀，说明
找到了一个候选单词。我们将$k_i$添加到三元组中的前缀$prefix$后，并纪录下这一结果。
如果$D'$是$D$的前缀，我们需要继续在这棵子树中查找。为此，我们将已$k_i$结尾的前缀，
剩余的数字串$D-D'$和该子树组成一个新的三元组，放入队列的尾部。

\begin{algorithmic}[1]
\Function{Look-Up-T9}{$T, D$}
  \State $R \gets \phi$
  \If{$T =$ NIL or $D = \phi$}
    \State \Return $R$
  \EndIf
  \State $n \gets |D|$
  \State $Q \gets \{(\phi, D, T)\}$
  \While{$Q \neq \phi$}
    \State $(prefix, D, T) \gets$ \Call{Pop}{$Q$}
    \For{$\forall (k_i, T_i) \in $ \Call{Children}{$T$}}
      \State $D' \gets$ \Call{Digits}{$k_i$}
      \If{$D' \sqsubset D$} \Comment{$D'$ is prefix of $D$}
        \State $R \gets R \cup \{$ \textproc{Take} $(n, prefix + k_i) \}$ \Comment{限制长度不超过$n$}
      \ElsIf{$D \sqsubset D'$}
        \State \textproc{Push}($Q, (prefix + k_i, D - D', T_i)$)
      \EndIf
    \EndFor
  \EndWhile
  \State \Return $R$
\EndFunction
\end{algorithmic}

函数\textproc{Digits}($S$)将字符串$S$转换为数字串。

\begin{algorithmic}[1]
\Function{Digits}{$S$}
  \State $D \gets \phi$
  \For{each $c \in S$}
    \State $D \gets D \cup \{M^{-1}_{T9}[c]\}$
  \EndFor
  \State \Return $D$
\EndFunction
\end{algorithmic}

下面的Python例子程序使用前缀树实现了T9输入法。

\lstset{language=Python}
\begin{lstlisting}
T9MAP={'2':"abc", '3':"def", '4':"ghi", '5':"jkl", \
       '6':"mno", '7':"pqrs", '8':"tuv", '9':"wxyz"}

T9RMAP = dict([(c, d) for d, cs in T9MAP.items() for c in cs])

def digits(w):
    return ''.join([T9RMAP[c] for c in w])

def lookup_t9(t, key):
    if t is None or key == "":
        return []
    res = []
    n = len(key)
    q = [("", key, t)]
    while q:
        prefix, key, t = q.pop(0)
        for k, tr in t.subtrees.items():
            ds = digits(k)
            if string.find(ds, key) == 0: # key is prefix of ds
                res.append((prefix + k)[:n])
            elif string.find(key, ds) == 0: # ds is prefix of key
                q.append((prefix + k, key[len(k):], tr))
    return res
\end{lstlisting}

\begin{Exercise}
\begin{itemize}
\item 使用Trie实现电子词典和T9输入法。
\item 对于返回多个候选结果的前缀树查找算法，如何保证输出的结果按照字典顺序排序？这会对性能产生怎样的影响？
\item 如果不使用惰性求值，如何实现函数式的电子词典和T9输入法？
\end{itemize}
\end{Exercise}

% ================================================================
%                 Short summary
% ================================================================
\section{小结}

本章一开始介绍了整数Trie和前缀树。基于整数前缀树的映射结构在编译器的实现中得到了重要的应用。字符Trie和字符前缀树可以看做是整数映射结构的自然扩展。它们可以被用来处理文字信息。作为例子，我们介绍了自动预测完成输入的电子词典和T9输入法。尽管和商业软件的实现不同，这些例子展示了如何使用Trie和前缀树来解决问题的方法。某些重要的数据结构，如后缀树和本章中介绍的内容紧密相关。读者可以参考附录D。

\ifx\wholebook\relax\else
\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein.
``Introduction to Algorithms, Second Edition''. Problem 12-1. ISBN:0262032937. The MIT Press. 2001（《算法导论》）

\bibitem{okasaki-int-map}
Chris Okasaki and Andrew Gill. ``Fast Mergeable Integer Maps''. Workshop on ML, September 1998, pages 77-86.  \url{http://www.cse.ogi.edu/~andy/pub/finite.htm}

\bibitem{patricia-morrison}
D.R. Morrison, ``PATRICIA -- Practical Algorithm To Retrieve  Information Coded In Alphanumeric", Journal of the ACM, 15(4), October 1968, pages 514-534.

\bibitem{wiki-suffix-tree}
Suffix Tree, Wikipedia. \url{http://en.wikipedia.org/wiki/Suffix_tree}

\bibitem{wiki-trie}
Trie, Wikipedia. \url{http://en.wikipedia.org/wiki/Trie}

\bibitem{wiki-t9}
T9 (predictive text), Wikipedia. \url{http://en.wikipedia.org/wiki/T9_(predictive_text)}

\bibitem{wiki-predictive-text}
Predictive text,
Wikipedia. \url{http://en.wikipedia.org/wiki/Predictive_text}

\end{thebibliography}

\end{document}
\fi
