\ifx\wholebook\relax \else
% ------------------------

\documentclass[b5paper]{article}
\usepackage[nomarginpar
  %, margin=.5in
]{geometry}

\addtolength{\oddsidemargin}{-0.05in}
\addtolength{\evensidemargin}{-0.05in}
\addtolength{\textwidth}{0.1in}

\usepackage[en]{../../../prelude}

\setcounter{page}{1}

\begin{document}

\title{Imperative delete for red-black tree}

\author{Xinyu LIU
\thanks{{\bfseries Xinyu LIU} \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\maketitle
\fi

\markboth{Red-black tree}{Elementary Algorithms}

\ifx\wholebook\relax
\chapter{Imperative delete for red-black tree}
\numberwithin{Exercise}{chapter}
\fi

\index{Red-black tree!Imperative delete}

The imperative $delete$ for red-black tree need handle more cases than $insert$. To resume balance after cut off a node, we perform rotations and re-coloring. When delete a black node, rule 5 will be violated because the number of black nodes along the paths through that node reduces by one. We introduced `doubly-black' node to maintain the number of black nodes unchanged.

Below example program adds `doubly black' to the color definition:

\lstset{frame = single}
\begin{lstlisting}[language = Bourbaki]
data Color { RED, BLACK, DOUBLY_BLACK };
\end{lstlisting}

When deleting a node, we re-use the binary search tree $delete$ i the first step. then further fix the balance if the deleted node is black.

\begin{algorithmic}[1]
\Function{Delete}{$T, x$}
  \State $p \gets$ \Call{Parent}{$x$}
  \State $q \gets$ NIL
  \If{\Call{Left}{$x$} = NIL}
    \State $q \gets$ \Call{Right}{$x$}
    \State \textproc{Replace}($x$, \Call{Right}{$x$}) \Comment{replace $x$ with its right sub-tree}
  \ElsIf{\Call{Right}{$x$} = NIL}
    \State $q \gets$ \Call{Left}{$x$}
    \State \textproc{Replace}($x$, \Call{Left{$x$}}) \Comment{replace $x$ with its right sub-tree}
  \Else
    \State $y \gets$ \textproc{Min}(\Call{Right}{$x$})
    \State $p \gets$ \Call{Parent}{$y$}
    \State $q \gets$ \Call{Right}{$y$}
    \State \Call{Key}{$x$} $\gets$ \Call{Key}{$y$}
    \State copy data from $y$ to $x$
    \State \textproc{Replace}($y$, \Call{Right}{$y$}) \Comment{replace $y$ with its right sub-tree}
    \State $x \gets y$
  \EndIf
  \If{\Call{Color}{$x$} = BLACK}
    \State $T \gets$ \textproc{Delete-Fix}($T$, \Call{Make-Black}{$p$, $q$}, $q$ = NIL?)
  \EndIf
  \State release $x$
  \State \Return $T$
\EndFunction
\end{algorithmic}

\textproc{Delete} takes the root $T$ and the node $x$ to be deleted. $x$ can be located through $lookup$. If $x$ has an empty sub-tree, we cut off $x$, then replace it with the other sub-tree $q$. Otherwise, we locate the minimum node $y$ in the right sub-tree of $x$, then replace $x$ with $y$. We cut off $y$ after that. If $x$ is black, we call \textproc{Make-Black}($p$, $q$) to maintain the blackness before further fixing.

\begin{algorithmic}[1]
\Function{Make-Black}{$p$, $q$}
  \If{$p$ = NIL and $q$ = NIL}
    \State \Return NIL \Comment{The tree was singleton}
  \ElsIf{$q$ = NIL}
    \State $n \gets$ Doubly Black NIL
    \State \Call{Parent}{$n$} $\gets p$
    \State \Return $n$
  \Else
    \State \Return \Call{Blacken}{$q$}
  \EndIf
\EndFunction
\end{algorithmic}

If both $p$ and $q$ are empty, we are deleting the only leaf from a singleton tree. The result is empty. If the parent $p$ is not empty, but $q$ is, we are deleting a black leaf. We use NIL to replace that black leaf. As NIL is already black, we change it to 'doubly black' NIL to maintain the blackness. Otherwise, if neither $p$ nor $q$ is empty, we call \textproc{Blacken}. Where if $q$ is red, it changes to black; if $q$ is already black, it changes to doubly black. As the next step, we need eliminate the doubly blackness through tree rotation and re-coloring. There are three different cases (\cite{CLRS}, pp292). The doubly black node is either branch or NIL in all the cases.

\textbf{Case 1}. {\em The sibling of the doubly black node is black, and it has a red sub-tree.} We can rotate the tree to fix the doubly black. There are 4 sub-cases, all can be transformed to a uniformed structure as shown in figure \ref{fig:del-case1}.

\begin{figure}[htbp]
   \centering
   \includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/del-case1.png}
   \caption{The doubly black node has a black sibling, and a red nephew. It can be fixed with a rotation.}
   \label{fig:del-case1}
\end{figure}

\begin{algorithmic}[1]
\Function{Delete-Fix}{$T$, $x$, $f$}
  \State $n \gets$ NIL
  \If{$f$ = True}  \Comment{$x$ is doubly black NIL}
    \State $n \gets x$
  \EndIf
  \If{$x$ = NIL} \Comment{Delete the singleton leaf}
    \State \Return NIL
  \EndIf
  \While{$x \neq T$ and \Call{Color}{$x$} $= \mathcal{B}^2$}
    \Comment{$x$ is doubly black, but not the root}
    \If{\Call{Sibling}{$x$} $\neq$ NIL} \Comment{The sibling is not empty}
        \State $s \gets$ \Call{Sibling}{$x$}
        \State ...
        \If{$s$ is black and \Call{Left}{$s$} is red}
          %\Comment{sibling: black, nephew: red}
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})}
            \Comment{$x$ is the left}
            \State set $x$, \Call{Parent}{$x$}, and \Call{Left}{$s$} all black
            \State $T \gets$ \Call{Rotate-Right}{$T$, $s$}
            \State $T \gets$ \textproc{Rotate-Left}($T$, \Call{Parent}{$x$})
          \Else \Comment{$x$ is the right}
            \State set $x$, \Call{Parent}{$x$}, $s$, and \Call{Left}{$s$} all black
            \State $T \gets$ \textproc{Rotate-Right}($T$, \Call{Parent}{$x$})
          \EndIf
        \ElsIf{$s$ is black and \Call{Right}{$s$} is red}
          %\Comment{sibling: black, nephew: red}
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})} \Comment{$x$ is the left}
            \State set $x$, \Call{Parent}{$x$}, $s$, and \Call{Right}{$s$} all black
            \State $T \gets$ \textproc{Rotate-Left}($T$, \Call{Parent}{$x$})
          \Else \Comment{$x$ is the right}
            \State set $x$, \Call{Parent}{$x$}, and \Call{Right}{$s$} all black
            \State $T \gets$ \Call{Rotate-Left}{$T$, $s$}
            \State $T \gets$ \textproc{Rotate-Right}($T$, \Call{Parent}{$x$})
          \EndIf
        \State ...
        \EndIf
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}

\textbf{Case 2}. {\em The sibling of the doubly black is red.} We can rotate the tree to change the doubly black node to black. As shown in figure \ref{fig:del-case2}, change $a$ or $c$ to black. We can add this fixing on top of the previous algorithm.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/del-case3.png}
  \caption{The sibling of the doubly black is red}
  \label{fig:del-case2}
\end{figure}

\begin{algorithmic}[1]
\Function{Delete-Fix}{$T$, $x$, $f$}
  \State $n \gets$ NIL
  \If{$f$ = True}  \Comment{$x$ is doubly black NIL}
    \State $n \gets x$
  \EndIf
  \If{$x$ = NIL} \Comment{Delete the singleton leaf}
    \State \Return NIL
  \EndIf
  \While{$x \neq T$ and \Call{Color}{$x$} $= \mathcal{B}^2$}
    %\Comment{$x$ isn't root and is doubly black}
    \If{\Call{Sibling}{$x$} $\neq$ NIL}
        \State $s \gets$ \Call{Sibling}{$x$}
        \If{$s$ is red}   \Comment{The sibling is red}
          \State set \Call{Parent}{$x$} red
          \State set $s$ black
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})} \Comment{$x$ is the left}
            \State $T \gets$ \textproc{Rotate-Left}{$T$, \Call{Parent}{$x$}}
          \Else \Comment{$x$ is the right}
            \State $T \gets$ \textproc{Rotate-Right}{$T$, \Call{Parent}{$x$}}
          \EndIf
        \ElsIf{$s$ is black and \Call{Left}{$s$} is red}
          %\Comment{The sibling is black, a nephew is red}
          \State ...
        \EndIf
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}

\textbf{Case 3}. {\em The sibling of the doubly black node, and its two sub-trees are all black.} In this case, we re-color the sibling to red, change the doubly black node back to black, then move the doubly blackness up to the parent. As shown in figure \ref{fig:del-case3}, there are two symetric sub-cases.

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.4]{../../../datastruct/tree/red-black-tree/img/del-case3.png}
  \caption{move the blackness up}
  \label{fig:del-case3}
\end{figure}

The sibling of the doubly black isn't empty in all above 3 cases. Otherwise, we change the doubly black node back to black, and move the blackness up. When reach the root, we force the root to be black to complete the fixing. It also terminates if the doubly black node is re-colored in the midway. At last, if the doubly black node passed in is empty, we turn it back to normal NIL.

\begin{algorithmic}[1]
\Function{Delete-Fix}{$T$, $x$, $f$}
  \State $n \gets$ NIL
  \If{$f$ = True}  \Comment{$x$ is a doubly black NIL}
    \State $n \gets x$
  \EndIf
  \If{$x$ = NIL} \Comment{Delete the singleton leaf}
    \State \Return NIL
  \EndIf
  \While{$x \neq T$ and \Call{Color}{$x$} $= \mathcal{B}^2$}
    %\Comment{$x$ isn't root and is doubly black}
    \If{\Call{Sibling}{$x$} $\neq$ NIL} \Comment{The sibling is not empty}
        \State $s \gets$ \Call{Sibling}{$x$}
        \If{$s$ is red} \Comment{The sibling is red}
          \State set \Call{Parent}{$x$} red
          \State set $s$ black
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})} \Comment{$x$ is the left}
            \State $T \gets$ \textproc{Rotate-Left}{$T$, \Call{Parent}{$x$}}
          \Else \Comment{$x$ is the right}
            \State $T \gets$ \textproc{Rotate-Right}{$T$, \Call{Parent}{$x$}}
          \EndIf
        \ElsIf{$s$ is black and \Call{Left}{$s$} is red}
          %\Comment{The sibling is black, a nephew is red}
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})}
            \Comment{$x$ is the left}
            \State set $x$, \Call{Parent}{$x$}, and \Call{Left}{$s$} all black
            \State $T \gets$ \Call{Rotate-Right}{$T$, $s$}
            \State $T \gets$ \textproc{Rotate-Left}($T$, \Call{Parent}{$x$})
          \Else \Comment{$x$ is the right}
            \State set $x$, \Call{Parent}{$x$}, $s$, and \Call{Left}{$s$} all black
            \State $T \gets$ \textproc{Rotate-Right}($T$, \Call{Parent}{$x$})
          \EndIf
        \ElsIf{$s$ is black and \Call{Right}{$s$} is red}
          %\Comment{The sibling is black, a nephew is red}
          \If{$x = $ \textproc{Left}(\Call{Parent}{$x$})}
            \Comment{$x$ is the left}
            \State set $x$, \Call{Parent}{$x$}, $s$, and \Call{Right}{$s$} all black
            \State $T \gets$ \textproc{Rotate-Left}($T$, \Call{Parent}{$x$})
          \Else \Comment{$x$ is the right}
            \State set $x$, \Call{Parent}{$x$}, and \Call{Right}{$s$} all black
            \State $T \gets$ \Call{Rotate-Left}{$T$, $s$}
            \State $T \gets$ \textproc{Rotate-Right}($T$, \Call{Parent}{$x$})
          \EndIf
        \ElsIf{$s$, \Call{Left}{$s$}, and \Call{Right}{$s$} are all black}
          %\Comment{The sibling and sub-trees are all black}
          \State set $x$ black
          \State set $s$ red
          \State \textproc{Blacken}(\Call{Parent}{$x$})
          \State $x \gets$ \Call{Parent}{$x$}
        \EndIf
    \Else \Comment{move the blackness up}
      \State set $x$ black
      \State \textproc{Blacken}(\Call{Parent}{$x$})
      \State $x \gets$ \Call{Parent}{$x$}
    \EndIf
  \EndWhile
  \State set $T$ black
  \If{$n \neq$ NIL}
    \State replace $n$ with NIL
  \EndIf
  \State \Return $T$
\EndFunction
\end{algorithmic}

When fixing the deletion result, we passed in the root $T$; the node (can be doubly black) to be fixed as $x$; and a flag $f$. The flag is true if the node to be fixed $x$ is doubly black NIL. We record the doubly black NIL with $n$, and replace $n$ with the normal NIL after fixing.

The following is the example deletion program in C++.

\lstset{language=C++}
\begin{lstlisting}
Node* del(Node* t, Node* x) {
    if (!x) return t;
    Node* parent = x->parent;
    Node* db = nullptr;        //doubly black
    Node* y;

    if (x->left == nullptr) {
        db = x->right;
        x->replaceWith(db);
    } else if (x->right == nullptr) {
        db = x->left;
        x->replaceWith(db);
    } else {
        y = min(x->right);
        parent = y->parent;
        db = y->right;
        x->key = y->key;
        y->replaceWith(db);
        x = y;
    }
    if (x->color == Color::BLACK)
        t = deleteFix(t, makeBlack(parent, db), db == nullptr);
    remove(x);
    return t;
}
\end{lstlisting}

Where \texttt{makeBlack} check if the node change to doubly black after deletion, and handle the special case of doubly black NIL.

\begin{lstlisting}
Node* makeBlack(Node* parent, Node* x) {
    if (!parent && ! x)
        return nullptr;
    if (!x)
        return Node::replace(parent, x, new Node(0, Color::DOUBLY_BLACK));
    return blacken(x);
}
\end{lstlisting}

The function \texttt{replace(parent, x, y)} replaces the child of the \texttt{parent}, which is \texttt{x}, with the node \texttt{y}.

\begin{lstlisting}
static Node* replace(Node* parent, Node* x, Node* y) {
    if (parent == nullptr) {
        if (y) y->parent = nullptr;
    } else if (parent->left == x) {
        parent->setLeft(y);
    } else {
        parent->setRight(y);
    }
    if (x) x->parent = nullptr;
    return y;
}
\end{lstlisting}

The function \texttt{blacken(node)} re-colors the red node to black, and re-colors the black node to doubly black.

\begin{lstlisting}
Node* blacken(Node* x) {
    x->color = isRed(x) ? Color::BLACK : Color::DOUBLY_BLACK;
    return x;
}
\end{lstlisting}

Below is the final fixing process.

\begin{lstlisting}
Node* deleteFix(Node* t, Node* db, bool isDBEmpty) {
    Node* dbEmpty = isDBEmpty ? db : nullptr;
    if (!db) return nullptr;    // remove the root from a leaf tree;
    while (db != t && db->color == Color::DOUBLY_BLACK) {
        if (db->sibling() != nullptr) {
            if (isRed(db->sibling())) {
                // the sibling is red, (transform to make the sibling black)
                setColors(db->parent, Color::RED,
                          db->sibling(), Color::BLACK);
                if (db == db->parent->left)
                    t = leftRotate(t, db->parent);
                else
                    t = rightRotate(t, db->parent);
            } else if (isBlack(db->sibling()) && isRed(db->sibling()->left)) {
                // the sibling is black, and one nephew is red
                if (db == db->parent->left) {
                    setColors(db, Color::BLACK,
                              db->parent, Color::BLACK,
                              db->sibling()->left, db->parent->color);
                    t = rightRotate(t, db->sibling());
                    t = leftRotate(t, db->parent);
                } else {
                    setColors(db, Color::BLACK,
                              db->parent, Color::BLACK,
                              db->sibling(), db->parent->color,
                              db->sibling()->left, Color::BLACK);
                    t = rightRotate(t, db->parent);
                }
            } else if (isBlack(db->sibling()) && isRed(db->sibling()->right)) {
                if (db == db->parent->left) {
                    setColors(db, Color::BLACK,
                              db->parent, Color::BLACK,
                              db->sibling(), db->parent->color,
                              db->sibling()->right, Color::BLACK);
                    t = leftRotate(t, db->parent);
                } else {
                    setColors(db, Color::BLACK,
                              db->parent, Color::BLACK,
                              db->sibling()->right, db->parent->color);
                    t = leftRotate(t, db->sibling());
                    t = rightRotate(t, db->parent);
                }
            } else if (isBlack(db->sibling()) &&
                       isBlack(db->sibling()->left) &&
                       isBlack(db->sibling()->right)) {
                // the sibling and both nephews are black.
                // move the blackness up
                setColors(db, Color::BLACK,
                          db->sibling(), Color::RED);
                blacken(db->parent);
                db = db->parent;
            }
        } else { // no sibling, move the blackness up
            db->color = Color::BLACK;
            blacken(db->parent);
            db = db->parent;
        }
    }
    t->color = Color::BLACK;
    if (dbEmpty) { // change the doubly black nil to nil
        dbEmpty->replaceWith(nullptr);
        delete dbEmpty;
    }
    return t;
}
\end{lstlisting}

Where \texttt{isBlack(node)} tests if a node is black, the NIL node is also black according to the red-black tree property.

\begin{lstlisting}
bool isBlack(Node* x) {
    return x == nullptr || x->color == Color::BLACK;
}

bool isRed(Node* x) {
    return x != nullptr && x->color == Color::RED;
}
\end{lstlisting}

The \texttt{setColors} is a set of auxiliary functions to re-color nodes.

\begin{lstlisting}
void setColors(Node* x, Color a, Node* y, Color b) { x->color = a; y->color = b; }

void setColors(Node* x, Color a, Node* y, Color b, Node* z, Color c) {
    setColors(x, a, y, b);
    z->color = c;
}

void setColors(Node* x, Color a, Node* y, Color b,
               Node* z, Color c, Node* q, Color d) {
    setColors(x, a, y, b);
    setColors(z, c, q, d);
}
\end{lstlisting}

Before returning the final result, the algorithm check the doubly black NIL, it calls the \texttt{replaceWith} method of the node, which is implemented with the \texttt{replace} function defined previously.

\begin{lstlisting}
void replaceWith(Node* y) {
    replace(parent, this, y);
}
\end{lstlisting}

The algorithm terminates when reach the root or the doubly blackness is eliminated. Consider the red-black tree is balanced, the deletion algorithm is bound to $O(\lg n)$ time for the tree contains $n$ nodes.

\begin{Exercise}

\begin{itemize}
\item Implement the red-black tree deletion algorithm in an imperative programming langauge.
\item Write a program in an imperative programming language to test if a given tree satisfies the 5 red-black tree properties. Use this program to verify the red-black tree deletion algorithm.
\end{itemize}

\end{Exercise}

\ifx\wholebook\relax \else
\begin{thebibliography}{99}

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein.
``Introduction to Algorithms, Second Edition''. ISBN:0262032937. The MIT Press. 2001

\end{thebibliography}

\expandafter\enddocument
\fi
