\ifx\wholebook\relax \else
% ------------------------

\documentclass[b5paper]{ctexart}

\usepackage[cn]{../../prelude}

\setcounter{page}{1}

\begin{document}

%--------------------------

\title{前言}

\author{刘新宇
\thanks{{\bfseries 刘新宇} \newline
  Email: liuxinyu95@gmail.com \newline}
  }

\maketitle
\fi

\markboth{前言}{基本算法}

尽管我们在课堂上学习基本算法，但除了编程竞赛，求职面试，很多人在工作中根本用不上。当人们谈到人工智能和机器学习算法时，实际上说的是数学模型而非基本算法和数据结构。即使在工作中遇到算法，大多数时候程序库中已经实现好了。我们只需要了解如何使用，而不用自己重新实现。

算法在解决一些“有趣”的问题时，会扮演关键角色。作为例子，让我们来看看下面这两个趣题。

\section{最小可用数}
\label{min-free} \index{最小可用数}

理查德$\cdot$伯德提出过一个问题：找出不在一个列表中出现的最小数字（\cite{fp-pearls}第一章）。我们经常使用数字作为标识某一实体的标签，例如身份证号，银行账户，电话号码等等。一个数字或者被占用，或者没有被占用。我们希望找到一个最小的没有被占用数字。假设数字都是非负整数，所有正在被使用的数字记录在一个列表中：

\begin{verbatim}
[18, 4, 8, 9, 16, 1, 14, 7, 19, 3, 0, 5, 2, 11, 6]
\end{verbatim}

不在这个列表中的最小整数是10。这个题目看上去是如此简单，我们可以立即写出下面解法：

\begin{algorithmic}[1]
\Function{Min-Free}{$A$}
  \State $x \gets 0$
  \Loop
    \If{$x \notin A$}
      \State \Return $x$
    \Else
      \State $x \gets x + 1$
    \EndIf
  \EndLoop
\EndFunction
\end{algorithmic}

其中符号$\notin$的实现如下：

\begin{algorithmic}[1]
\Function{`$\notin$'}{$x, X$}
  \For{$i \gets 1 $ to $|X|$}
    \If{$x = X[i]$}
      \State \Return False
    \EndIf
  \EndFor
  \State \Return True
\EndFunction
\end{algorithmic}

有些编程语言内置了这一线性查找的实现，下面是一段例子代码。

\lstset{language=Python, frame=single}
\begin{lstlisting}
def minfree(lst):
    i = 0
    while True:
        if i not in lst:
            return i
        i = i + 1
\end{lstlisting}

当列表存储了几百万个数字时，这个方法的的性能很快变差。它消耗的时间和列表长度的平方成正比。在一台双核2.10GHz处理器，2G内存的计算机上，其C语言实现需要5.4秒才能在十万个数字中找到答案。当数量上升到一百万时，则耗时达到8分钟。

\subsection{改进}
改进这一解法的关键基于这一事实：对于任何$n$个非负整数$x_1, x_2, ..., x_n$，如果存在小于$n$的可用整数，必然存在某个$x_i$不在$[0, n)$这个范围内。否则这些整数一定是$0, 1, ..., n - 1$的某个排列，这种情况下，最小的可用整数是$n$。于是我们有如下结论：

\be
\textit{minfree}(x_1, x_2, ..., x_n) \leq n
\label{eq:min-free}
\ee

为此我们可以用一个长度为$n + 1$的数组，来标记区间$[0, n]$内的某个整数是否可用。

\begin{algorithmic}[1]
\Function{Min-Free}{$A$}
  \State $F \gets $[False, False, ..., False] where $|F| = n+1$
  \For{$\forall x \in A$}
    \If{$x < n$}
      \State $F[x] \gets$ True
    \EndIf
  \EndFor
  \For{$i \gets [0, n]$}
    \If{$F[i] =$ False}
      \State \Return $i$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}

其中第2行将标志数组中的所有值初始化为假。接着我们遍历$A$中的所有数字，只要小于$n$，就将相应的标记置为真。接下来我们再次扫描标志数组，找到第一个值为假的位置。整个算法用时和$n$成正比。我们使用了$n + 1$而不是$n$个标志，这样无需额外处理，就可以应对$sorted(A) = [0, 1, 2, ..., n-1]$的特殊情况。

虽然这个方法只需要线性时间，但是它需要$O(n)$的空间来存储标志。我们还可以继续优化。每次查找都要申请长度为$n + 1$的数组；查找结束后，这个数组又被释放了。反复的申请和释放会消耗大量时间。我们可以预先准备好足够长的数组，然后每次查找都复用它。另外，我们可以使用二进制的位来保存标志，从而节约空间。下面的C语言例子程序实现了这两点改进：

\begin{lstlisting}[language=C]
#define N 1000000
#define WORD_LENGTH (sizeof(int) * 8)

void setbit(unsigned int* bits, unsigned int i) {
    bits[i / WORD_LENGTH] |= 1 << (i % WORD_LENGTH);
}

int testbit(unsigned int* bits, unsigned int i) {
    return bits[i / WORD_LENGTH] & (1 << (i % WORD_LENGTH));
}

unsigned int bits[N / WORD_LENGTH + 1];

int minfree(int* xs, int n) {
  int i, len = N/WORD_LENGTH + 1;
  for (i = 0; i < len; ++i) {
      bits[i]=0;
  }
  for (i=0; i < n; ++i) {
      if(xs[i] < n) {
          setbit(bits, xs[i]);
      }
  }
  for (i=0; i <= n; ++i) {
      if (!testbit(bits, i)) {
          return i;
      }
  }
}
\end{lstlisting}

在相同的计算机上，这段程序仅用0.023秒就可以处理一百万个数字。

\subsection{分而治之}
我们在速度上的改进是以空间上的消耗为代价的。由于维护了一个长度为$n$的标志数组，当$n$很大时，空间就会成为新的瓶颈。分而治之的策略将问题分解为若干规模较小的子问题，然后逐步解决它们以得到最终的结果。

我们可以将所有满足$x_i \leq \lfloor n/2 \rfloor$的整数放入一个子序列$A'$；将其它整数放入另外一个序列$A''$。根据公式\ref{eq:min-free}，如果序列$A'$的长度正好是$\lfloor n/2 \rfloor$，这说明前一半的整数$A'$已经“满了”，最小可用整数一定可以在$A''$中找到。否则，最小可用整数一定在$A'$中。总之，通过这一划分，问题的规模减小了。

需要注意的是，当在子序列$A''$中递归查找时，边界情况发生了一些变化。我们不再是从0开始寻找最小可用整数，查找的下界变成了$\lfloor n/2 \rfloor + 1$。因此我们的算法应定义为$search(A, l, u)$，其中$l$是下界，$u$是上界。递归的边界条件是当序列为空时，我们返回下界$l$作为结果。

\[
minfree(A) = search(A, 0, |A|-1)
\]

\[
\begin{array}{rcl}
search(\nil, l, u) & = & l \\
search(A, l, u) & = & \begin{cases}
       |A'| = m - l + 1 : & search(A'', m+1, u) \\
       otherwise : & search(A',  l, m) \\
\end{cases}
\end{array}
\]

其中

\[ \begin{array}{rcl}
m & = & \displaystyle \lfloor \frac{l+u}{2} \rfloor \\
A' & = & [ x | x \in A, x \leq m ] \\
A''& = & [ x | x \in A, x > m ] \\
\end{array} \]

这一方法并不需要额外的空间\footnote{递归需要$O(\lg n)$的栈空间，但可以通过尾递归优化消除。}。每次调用需要进行$O(|A|)$次比较来划分出子序列$A'$和$A''$。每次问题的规模都会减半，所以算法用时为$T(n) = T(n/2) + O(n)$，通过主定理化简得到结果$O(n)$。我们也可以这样分析：第一次需要$O(n)$次比较来划分子序列$A'$和$A''$，第二次需要比较$O(n/2)$次，第三次需要比较$O(n/4)$次……总时间为$O(n + n/2 + n/4 + ...) = O(2n) = O(n)$。在定义中我们用表达式$[a | a \in A, p(a)]$来定义列表。它和集合表达式$\{a | a \in A, p(a) \}$有所不同。下面的Haskell例子代码实现了分而治之的算法。

\begin{Haskell}
minFree xs = bsearch xs 0 (length xs - 1)

bsearch xs l u | xs == [] = l
               | length as == m - l + 1 = bsearch bs (m+1) u
               | otherwise = bsearch as l m
    where
      m = (l + u) `div` 2
      (as, bs) = partition (<=m) xs
\end{Haskell}

\subsection{简洁与性能}
有人会担心这一算法的性能。递归的深度为$O(\lg n)$，调用栈的大小也是$O(\lg n)$。我们可以通过将递归转换为迭代来避免空间上的占用：

\begin{algorithmic}[1]
\Function{Min-Free}{$A$}
  \State $l \gets 0, u \gets |A|$
  \While{$u - l > 0$}
    \State $m \gets l + \dfrac{u - l}{2}$
    \State $left \gets l$
    \For{$right \gets l$ to $u - 1$}
      \If{$A[right] \leq m$}
        \State $A[left] \leftrightarrow A[right]$
        \State $left \gets left + 1$
      \EndIf
    \EndFor
    \If{$left < m + 1$}
      \State $u \gets left$
    \Else
      \State $l \gets left$
    \EndIf
  \EndWhile
\EndFunction
\end{algorithmic}

如图\ref{fig:divide}所示，这段程序对数组中的元素进行划分。$left$之前的元素都不大于$m$，而$left$和$right$之间的元素都大于$m$。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.7]{img/divide-by-m.ps}
  \caption{数组划分。位于$0 \leq i < left$的元素满足$A[i] \leq m$，位于$left \leq i < right$的元素满足$A[i] > m$，剩余的元素尚未处理。}
  \label{fig:divide}
\end{figure}

这一解法运行快速并且不需要额外的栈空间。但前面的递归算法更显简洁。不同读者的偏好可能会有所不同。

\section{正规数}

第二道趣题是寻找第1500个正规数。正规数就是只含有2、3、5这三个因子的自然数。因为最大的素因子是5，所以在数论中又叫作5-光滑数。在计算机科学中又叫作哈明数以纪念理查德$\cdot$哈明。2、3、5本身自然也是正规数。$60 = 2^23^15^1$是第25个正规数。数字$21 = 2^03^17^1$由于含有因子7，所以不是正规数。我们定义$1=2^03^05^0$是第0个正规数。前10个正规数如下：

1, 2, 3, 4, 5, 6, 8, 9, 10, 12, ...

\subsection{穷举法}
我们可以从1开始，逐一检查所有自然数，对于每个整数，把2、3、5这些因子不断去掉，然后检查最终结果是否为1：

\begin{algorithmic}[1]
\Function{Regular-Number}{$n$}
  \State $x \gets 1$
  \While{$n > 0$}
    \State $x \gets x + 1$
    \If{\Call{Valid?}{$x$}}
      \State $n \gets n - 1$
    \EndIf
  \EndWhile
  \State \Return $x$
\EndFunction
\Statex
\Function{Valid?}{$x$}
  \While{$x \bmod 2 = 0$}
    \State $x \gets \lfloor x / 2 \rfloor$
  \EndWhile
  \While{$x \bmod 3 = 0$}
    \State $x \gets \lfloor x / 3 \rfloor$
  \EndWhile
  \While{$x \bmod 5 = 0$}
    \State $x \gets \lfloor x / 5 \rfloor$
  \EndWhile
  \State \Return $x = 1$ ?
\EndFunction
\end{algorithmic}

穷举法对于较小的$n$没有问题。在同样的计算机上，其C语言实现用时40.39秒才找到第1500个正规数（860934420）。当$n$增加到15000时，即使10分钟也无法结束。

\subsection{构造性解法}
在上面的暴力解法中，取模运算和除法运算很耗时\cite{Bentley}。并且这些运算被循环执行了很多次。我们可以转换一下思路，不再检查一个数是否仅含有是2、3或5的因子，而是从这三个因子中构造需要的整数。

我们从1开始，分别乘以2或3或5来生成整数。这样问题就变成如何依次生成丑数。我们可以使用队列这种数据结构来解决这个问题。

队列从一侧放入元素，然后从另一侧取出元素。所以先放入的元素会先被取出。这一特性被称为先进先出FIFO(First-In-First-Out)。

我们的思路是先把1作为唯一的元素放入队列，然后我们不断从队列另一侧取出元素，分别乘以2、3和5，这样就得到了3个新的元素。然后把它们按照大小顺序放入队列。注意，这样产生的整数有可能已经在队列中存在了。这种情况下，我们需要丢弃重复产生的元素。另外新产生的整数还有可能小于队列尾部的某些元素，所以我们在插入时，需要保持它们在队列中的大小顺序。图\ref{fig:queues}描述了这一思路的步骤。

根据这一思路的算法实现如下：

%\begin{algorithm}
\begin{algorithmic}[1]
\Function{Get-Number}{$n$}
  \State $Q \gets NIL$
  \State \Call{Enqueue}{$Q, 1$}
  \While{$n > 0$}
    \State $x \gets$ \Call{Dequeue}{$Q$}
    \State \Call{Unique-Enqueue}{$Q, 2x$}
    \State \Call{Unique-Enqueue}{$Q, 3x$}
    \State \Call{Unique-Enqueue}{$Q, 5x$}
    \State $n \gets n-1$
  \EndWhile
  \State \Return $x$
\EndFunction
\Statex
\Function{Unique-Enqueue}{$Q, x$}
  \State $i \gets 0$
  \While{$i < |Q| \wedge Q[i] < x$}
    \State $i \gets i + 1$
  \EndWhile
  \If{$i < |Q| \wedge x = Q[i]$}
    \State \Return
  \EndIf
  \State \Call{Insert}{$Q, i, x$}
\EndFunction
\end{algorithmic}
%\end{algorithm}

\begin{figure}[htbp]
  \centering
  \subcaptionbox{初始状态，队列仅含有唯一的元素1}{\includegraphics[scale=0.5]{img/q1.ps}}
  \hspace{.1\textwidth}
  \subcaptionbox{新产生的元素2、3和5加入队列}{\includegraphics[scale=0.5]{img/q2.ps}}
  \\
  \subcaptionbox{新产生的元素4、6和10按照顺序被插入队列}{\includegraphics[scale=0.5]{img/q3.ps}}
  \hspace{.1\textwidth}
  \subcaptionbox{新产生的元素9和15加入队列，重复元素6被丢弃}{\includegraphics[scale=0.5]{img/q4.ps}}
  \caption{使用队列依次生成丑数的前4个步骤} \label{fig:queues}
\end{figure}

在将元素插入队列时，算法需要$O(|Q|)$时间找到合适位置。如果已经存在，则直接返回。

粗略估计，队列的长度会随着$n$增加（每取出一个元素会插入最多三个新元素，增加的比率$\leq 2$），所以总运行时间为$O(1+2+3+...+n) = O(n^2)$。

图\ref{fig:big-O-1q}的数据显示了队列的访问次数和$n$之间的关系，这些点连成了二次曲线，反映了算法的复杂度是$O(n^2)$。

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.5]{img/big-O-1q.eps}
  \caption{队列访问次数和$n$的关系} \label{fig:big-O-1q}
\end{figure}

依照此方法实现的C语言程序仅用时0.016秒就输出了正确答案859963392，比暴力解法快了2500倍。

%% Functional 1Q solution
这一解法也可以用递归的方式给出，令$X$为所有仅含有因子2、3或5的整数的无穷序列。下面的等式给出了一个有趣的关系。

\be
  X = \{1\} \cup \{2x: \forall x \in X\} \cup \{3x: \forall x \in X \} \cup \{5x: \forall x \in X \}
\ee

其中符号$\cup$表示去除重复并保持大小顺序。若$X=\{x_1, x_2, x_3...\}$，$Y=\{y_1, y_2, y_3, ...\}$，$X' = \{x_2, x_3, ...\}$，$Y'=\{y_2, y_3, ...\}$，我们可以定义$\cup$如下：

\[
X \cup Y = \left \{
  \begin{array}{r@{\quad:\quad}l}
  X & Y = \phi \\
  Y & X = \phi \\
  \{ x_1, X' \cup Y \} & x_1 < y_1 \\
  \{ x_1, X' \cup Y' \} & x_1 = y_1 \\
  \{ y_1, X \cup Y' \} & x_1 > y_1
  \end{array}
\right.
\]

在支持惰性求值的函数式编程语言，例如Haskell中，上述无穷序列及函数可以定义为如下代码：

\begin{lstlisting}[style=Haskell]
ns = 1:merge (map (*2) ns) (merge (map (*3) ns) (map (*5) ns))

merge (x:xs) (y:ys) | x <y = x : merge xs (y:ys)
                    | x ==y = x : merge xs ys
                    | otherwise = y : merge (x:xs) ys
\end{lstlisting}

通过求\texttt{last \$ take 1500}，我们可以得到第1500个丑数：

\begin{verbatim}
>last $ take 1500 ns
859963392
\end{verbatim}

\subsection{改进二、使用多个队列}
上面的解法虽然比暴力法快了很多，但是仍然有一些不足。它会产生很多的重复的元素，并且最终都被丢弃了。其次，它需要扫描队列以保证队列中的元素有序。因此入队操作从常数时间$O(1)$退化为线性时间$O(|Q|)$。

我们可以用三个队列来进行改进。这三个队列表示为$Q_2$，$Q_3$和$Q_5$。它们初始化为$Q_2=\{ 2 \}$，$Q_3 = \{ 3\}$和$Q_5 = \{ 5 \}$。我们每次从这三个队列的头部选择最小的一个元素$x$取出，然后进行下面的检查：

\begin{itemize}
\item 如果$x$是从$Q_2$取出的，我们将$2x$加入$Q_2$，$3x$加入$Q_3$，$5x$加入$Q_5$。
\item 如果$x$是从$Q_3$取出的，我们只将$3x$加入$Q_3$，$5x$加入$Q_5$，而不需要将$2x$加入$Q_2$。这是因为$2x$已经在$Q_3$中了。
\item 如果$x$是从$Q_5$取出的，我们只将$5x$加入$Q_5$，而不需要处理$2x$和$3x$了。
\end{itemize}

我们不断从这三个队列中取出最小的，直到取出第$n$个元素。图\ref{fig:q235}给出了构造丑数的前4步。

\begin{figure}[htbp]
  \centering
  \subcaptionbox{初始状态，2、3和5作为三个队列的唯一元素。新元素4、6和10被分别加入三个队列。}{\includegraphics[scale=0.5]{img/q235-1.ps}}
  \subcaptionbox{新元素9和15被加入队列。}{\includegraphics[scale=0.5]{img/q235-2.ps}} \\
  \subcaptionbox{新元素8、12和20被加入队列。}{\includegraphics[scale=0.5]{img/q235-3.ps}} \\
  \subcaptionbox{新元素25被加入队列。}{\includegraphics[scale=0.5]{img/q235-4.ps}}
  \caption{使用三个队列$Q_2$、$Q_3$和$Q_5$来构造丑数的前4步}
  \label{fig:q235}
\end{figure}

按照这个思路，算法可以实现如下。

\begin{algorithmic}[1]
\Function{Get-Number}{$n$}
  \If{$n = 1$}
    \State \Return $1$
  \Else
    \State $Q_2 \gets \{ 2 \}$
    \State $Q_3 \gets \{ 3 \}$
    \State $Q_5 \gets \{ 5 \}$
    \While{$n > 1$}
      \State $x \gets min($\Call{Head}{$Q_2$}, \Call{Head}{$Q_3$}, \Call{Head}{$Q_5$}$)$
      \If{$x = $ \Call{Head}{$Q_2$}}
        \State \Call{Dequeue}{$Q_2$}
        \State \Call{Enqueue}{$Q_2, 2x$}
        \State \Call{Enqueue}{$Q_3, 3x$}
        \State \Call{Enqueue}{$Q_5, 5x$}
      \ElsIf{$x=$ \Call{Head}{$Q_3$}}
        \State \Call{Dequeue}{$Q_3$}
        \State \Call{Enqueue}{$Q_3, 3x$}
        \State \Call{Enqueue}{$Q_5, 5x$}
      \Else
        \State \Call{Dequeue}{$Q_5$}
        \State \Call{Enqueue}{$Q_5, 5x$}
      \EndIf
      \State $n \gets n - 1$
    \EndWhile
    \State \Return $x$
  \EndIf
\EndFunction
\end{algorithmic}

算法循环$n$次，每次循环，它从三个队列中取出最小的一个元素，这一步需要常数时间。接着它根据取出元素所在的队列，产生一到三个新元素放入队列，这一步也是常数时间。因此整个算法是$O(n)$的。按照此算法实现的C++程序如下，它仅用了不到1$\mu$秒就输出了第1500个丑数859963392。

\lstset{language=C++}
\begin{lstlisting}
typedef unsigned long Integer;

Integer get_number(int n) {
    if(n==1)
        return 1;
    queue<Integer> Q2, Q3, Q5;
    Q2.push(2);
    Q3.push(3);
    Q5.push(5);
    Integer x;
    while(n-- > 1) {
        x = min(min(Q2.front(), Q3.front()), Q5.front());
        if(x==Q2.front()) {
            Q2.pop();
            Q2.push(x*2);
            Q3.push(x*3);
            Q5.push(x*5);
        } else if(x==Q3.front()) {
            Q3.pop();
            Q3.push(x*3);
            Q5.push(x*5);
        } else {
            Q5.pop();
            Q5.push(x*5);
        }
    }
    return x;
}
\end{lstlisting}

这一解法也可以用函数式的方式实现。我们定义函数$take(n)$，返回第$n$个仅由2、3或5为因子构成的整数。

\[
  take(n) = f(n, \{1\}, \{2\}, \{3\}, \{5\})
\]
其中
\[
 f(n, X, Q_2, Q_3, Q_5) = \left \{
  \begin{array}{r@{\quad:\quad}l}
  X & n = 1 \\
  f(n-1, X \cup \{x\}, Q_2', Q_3', Q_5') & otherwise
  \end{array}
\right.
\]

\[
 x = min(Q_{21}, Q_{31}, Q_{51})
\]
\[
 Q_2', Q_3', Q_5' = \left \{
 \begin{array}{r@{\quad:\quad}l}
 \{Q_{22}, Q_{23}, ...\} \cup \{2x\}, Q_3 \cup \{3x\}, Q_5 \cup \{5x\} & x = Q_{21} \\
 Q_2, \{Q_{32}, Q_{33}, ...\} \cup \{3x\}, Q5 \cup \{5x\} & x = Q_{31} \\
 Q_2, Q_3, \{Q_{52}, Q_{53}, ...\} \cup \{5x\} & x = Q_{51}
 \end{array}
 \right.
\]

下面的Haskell程序实现了上面的定义。

\begin{lstlisting}[style=Haskell]
ks 1 xs _ = xs
ks n xs (q2, q3, q5) = ks (n-1) (xs++[x]) update
    where
      x = minimum $ map head [q2, q3, q5]
      update | x == head q2 = ((tail q2)++[x*2], q3++[x*3], q5++[x*5])
             | x == head q3 = (q2, (tail q3)++[x*3], q5++[x*5])
             | otherwise = (q2, q3, (tail q5)++[x*5])

takeN n = ks n [1] ([2], [3], [5])
\end{lstlisting} %$

执行\texttt{last \$ takeN 1500}就可输出答案859963392。

% ================================================================
%                 Short summary
% ================================================================
\section{小结}
回顾这两个有趣的例题，暴力解法都捉襟见肘。对于第一题，暴力解法尚能解决较短的列表，而对于第二题，暴力解法根本行不通。

第一个例子展示了算法的力量，第二个例子展示了数据结构的重要性。有很多有趣的题目，在计算机发明之前很难解决。但是通过编程和使用计算机，我们可以用和传统方式完全不同的方法找到答案。和中小学数学课上所学的方法相比，这样的方法并没有被普遍教授。

虽然优秀的算法、数据结构和数学书籍汗牛充栋，但是对过程式的解法和函数式的解法进行对比的却寥寥无几。从上面的例子中，可以看到有时函数式解法十分简洁，并且很接近我们在数学课上所熟悉的思考方式。

本书力图同时介绍命令式和函数式的算法和数据结构。Okasaki的著作\cite{okasaki-book}中有很多函数式的数据结构可供进一步参考。关于命令式的内容可以参考一些经典的教科书\cite{CLRS}以及维基百科。本书的例子代码使用了多种编程语言，包括C、C++、Python、Haskell和Lisp方言Scheme，读者可以从 https://github.com/liuxinyu95/AlgoXY 上下载本书的全部例子代码。为了让具有不同背景的读者都容易阅读，所有算法都提供了伪代码和数学函数描述。

由于时间仓促，书中难免存在错误，欢迎广大读者和专家批评指正，提供意见和反馈。本书作者电子邮箱：liuxinyu95@gmail.com。

\section{内容组织}
在接下来的章节中，我们将先介绍基本的数据结构，此后的一些算法都会用到它们。

我们首先介绍数据结构中的“Hello world”――二叉搜索树，接下来讲解如何解决二叉树的平衡问题。然后介绍更多有趣的树，其中Trie和前缀树可以用于文字处理，而B树则广泛应用于文件系统和数据库。

第二部分是关于堆的。我们给出一个抽象堆的定义，然后介绍使用数组和各种二叉树实现的二叉堆（Binary Heap）。接着扩展到其他的堆包括二项式堆、斐波那契堆和Pairing堆。

数组和队列通常被认为是简单的数据结构，但我们将在第三部分看到，它们实现起来并不容易。

作为基本的排序算法，我们将介绍命令式和函数式的插入排序，快速排序和归并排序等算法。

最后的部分是关于查找和搜索的，除了基本算法，我们也会介绍诸如KMP这样的文字匹配算法。

本书的附录介绍了关于链表的基本内容。

\ifx\wholebook\relax \else
\begin{thebibliography}{99}

\bibitem{fp-pearls}
Richard Bird. ``Pearls of functional algorithm design''. Cambridge University Press; 1 edition (November 1, 2010). ISBN-10: 0521513383. pp1 - pp6.

\bibitem{Bentley}
Jon Bentley. ``Programming Pearls(2nd Edition)''. Addison-Wesley Professional; 2 edition (October 7, 1999). ISBN-13: 978-0201657883 （中文版：《编程珠玑》）

\bibitem{okasaki-book}
Chris Okasaki. ``Purely Functional Data Structures''. Cambridge university press, (July 1, 1999), ISBN-13: 978-0521663502

\bibitem{CLRS}
Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein. ``Introduction to Algorithms, Second Edition''. The MIT Press, 2001. ISBN: 0262032937. （中文版：《算法导论》）

\end{thebibliography}

\expandafter\enddocument
%\end{document}

\fi
